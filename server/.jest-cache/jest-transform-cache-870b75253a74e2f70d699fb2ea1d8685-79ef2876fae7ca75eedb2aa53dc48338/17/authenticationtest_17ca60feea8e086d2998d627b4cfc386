4adfd3b43a6878b2fa07617b768a03b5
/**
 * Authentication Service - Comprehensive Test Coverage
 * Addresses Issue #264: Critical test coverage gaps
 */
import { describe, test, expect, jest, beforeEach } from '@jest/globals';
// Mock dependencies
jest.mock('bcryptjs');
jest.mock('jsonwebtoken');
jest.mock('@teaching-engine/database');
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { PrismaClient } from '@teaching-engine/database';
import { generateAuthToken, hashPassword, validatePassword, verifyToken, authenticate, checkPermissions } from '@/services/authService';
describe('Authentication Service - Critical Path Testing', () => {
    let mockPrisma;
    beforeEach(() => {
        jest.clearAllMocks();
        mockPrisma = new PrismaClient();
        process.env.JWT_SECRET = 'test-secret-key';
    });
    describe('JWT Token Generation', () => {
        test('generates valid JWT tokens with correct payload', async () => {
            const userId = '123';
            const mockToken = 'mock.jwt.token';
            jwt.sign.mockReturnValue(mockToken);
            const token = await generateAuthToken(userId);
            expect(jwt.sign).toHaveBeenCalledWith({ userId, iat: expect.any(Number) }, 'test-secret-key', { expiresIn: '7d' });
            expect(token).toBe(mockToken);
        });
        test('throws error when JWT_SECRET is missing', async () => {
            delete process.env.JWT_SECRET;
            await expect(generateAuthToken('123'))
                .rejects.toThrow('JWT_SECRET environment variable is required');
        });
        test('generates tokens with custom expiration', async () => {
            const userId = '123';
            const customExpiry = '1h';
            jwt.sign.mockReturnValue('mock.token');
            await generateAuthToken(userId, customExpiry);
            expect(jwt.sign).toHaveBeenCalledWith(expect.any(Object), expect.any(String), { expiresIn: customExpiry });
        });
        test('handles token generation failures gracefully', async () => {
            jwt.sign.mockImplementation(() => {
                throw new Error('Token generation failed');
            });
            await expect(generateAuthToken('123'))
                .rejects.toThrow('Token generation failed');
        });
    });
    describe('Password Security', () => {
        test('hashes passwords with bcrypt using correct salt rounds', async () => {
            const plaintext = 'TestPassword123!';
            const hashedPassword = '$2a$10$mockedHashValue';
            bcrypt.hash.mockResolvedValue(hashedPassword);
            const result = await hashPassword(plaintext);
            expect(bcrypt.hash).toHaveBeenCalledWith(plaintext, 10);
            expect(result).toBe(hashedPassword);
        });
        test('validates password strength requirements', async () => {
            const weakPasswords = [
                '123456', // Too simple
                'password', // Common password
                'qwerty', // Common pattern
                'short', // Too short
                'nouppercase1!', // No uppercase
                'NOLOWERCASE1!', // No lowercase
                'NoNumbers!', // No numbers
                'NoSpecial123', // No special characters
            ];
            for (const weakPassword of weakPasswords) {
                await expect(validatePassword(weakPassword))
                    .rejects.toThrow('Password does not meet security requirements');
            }
        });
        test('accepts strong passwords', async () => {
            const strongPasswords = [
                'StrongPass123!',
                'C0mpl3x!P@ssw0rd',
                'Secure#Pass2023',
                'V@lidP@ssw0rd123',
            ];
            for (const strongPassword of strongPasswords) {
                await expect(validatePassword(strongPassword))
                    .resolves.toBe(true);
            }
        });
        test('compares passwords correctly', async () => {
            const plaintext = 'TestPassword123!';
            const hash = '$2a$10$hashedValue';
            bcrypt.compare.mockResolvedValue(true);
            const isValid = await bcrypt.compare(plaintext, hash);
            expect(isValid).toBe(true);
            expect(bcrypt.compare).toHaveBeenCalledWith(plaintext, hash);
        });
    });
    describe('Token Verification', () => {
        test('verifies valid tokens successfully', async () => {
            const mockPayload = { userId: '123', iat: Date.now() / 1000 };
            const mockToken = 'valid.jwt.token';
            jwt.verify.mockReturnValue(mockPayload);
            const result = await verifyToken(mockToken);
            expect(jwt.verify).toHaveBeenCalledWith(mockToken, 'test-secret-key');
            expect(result).toEqual(mockPayload);
        });
        test('rejects expired tokens', async () => {
            const mockToken = 'expired.jwt.token';
            jwt.verify.mockImplementation(() => {
                throw new jwt.TokenExpiredError('jwt expired', new Date());
            });
            await expect(verifyToken(mockToken))
                .rejects.toThrow('jwt expired');
        });
        test('rejects malformed tokens', async () => {
            const malformedTokens = [
                '',
                'invalid',
                'not.a.token',
                'malformed..token',
            ];
            for (const token of malformedTokens) {
                jwt.verify.mockImplementation(() => {
                    throw new jwt.JsonWebTokenError('jwt malformed');
                });
                await expect(verifyToken(token))
                    .rejects.toThrow('jwt malformed');
            }
        });
        test('handles missing JWT secret during verification', async () => {
            delete process.env.JWT_SECRET;
            await expect(verifyToken('any.token'))
                .rejects.toThrow('JWT_SECRET environment variable is required');
        });
    });
    describe('Authentication Flow', () => {
        test('authenticates valid credentials successfully', async () => {
            const email = 'test@example.com';
            const password = 'ValidPass123!';
            const hashedPassword = '$2a$10$hashedPassword';
            const mockUser = {
                id: '123',
                email,
                password: hashedPassword,
                name: 'Test User',
            };
            mockPrisma.user.findUnique = jest.fn().mockResolvedValue(mockUser);
            bcrypt.compare.mockResolvedValue(true);
            jwt.sign.mockReturnValue('mock.token');
            const result = await authenticate(email, password, mockPrisma);
            expect(mockPrisma.user.findUnique).toHaveBeenCalledWith({
                where: { email },
            });
            expect(bcrypt.compare).toHaveBeenCalledWith(password, hashedPassword);
            expect(result).toEqual({
                user: expect.objectContaining({
                    id: mockUser.id,
                    email: mockUser.email,
                    name: mockUser.name,
                }),
                token: 'mock.token',
            });
            expect(result.user).not.toHaveProperty('password');
        });
        test('rejects non-existent users', async () => {
            mockPrisma.user.findUnique = jest.fn().mockResolvedValue(null);
            await expect(authenticate('nonexistent@example.com', 'password', mockPrisma))
                .rejects.toThrow('Invalid credentials');
        });
        test('rejects incorrect passwords', async () => {
            const mockUser = {
                id: '123',
                email: 'test@example.com',
                password: '$2a$10$hashedPassword',
            };
            mockPrisma.user.findUnique = jest.fn().mockResolvedValue(mockUser);
            bcrypt.compare.mockResolvedValue(false);
            await expect(authenticate('test@example.com', 'wrongpassword', mockPrisma))
                .rejects.toThrow('Invalid credentials');
        });
        test('handles database errors gracefully', async () => {
            mockPrisma.user.findUnique = jest.fn().mockRejectedValue(new Error('Database connection failed'));
            await expect(authenticate('test@example.com', 'password', mockPrisma))
                .rejects.toThrow('Database connection failed');
        });
    });
    describe('SQL Injection Prevention', () => {
        test('sanitizes email input against SQL injection', async () => {
            const maliciousInputs = [
                "' OR '1'='1",
                "admin'--",
                "1; DROP TABLE users;--",
                "' UNION SELECT * FROM users--",
                "admin' OR 1=1--",
            ];
            for (const maliciousInput of maliciousInputs) {
                mockPrisma.user.findUnique = jest.fn().mockResolvedValue(null);
                await expect(authenticate(maliciousInput, 'password', mockPrisma))
                    .rejects.toThrow('Invalid credentials');
                // Verify Prisma was called with sanitized input
                expect(mockPrisma.user.findUnique).toHaveBeenCalledWith({
                    where: { email: maliciousInput },
                });
            }
        });
    });
    describe('Permission Checking', () => {
        test('allows access for users with correct permissions', async () => {
            const user = {
                id: '123',
                role: 'ADMIN',
                permissions: ['read', 'write', 'delete'],
            };
            const hasPermission = await checkPermissions(user, 'write');
            expect(hasPermission).toBe(true);
        });
        test('denies access for users without required permissions', async () => {
            const user = {
                id: '123',
                role: 'USER',
                permissions: ['read'],
            };
            const hasPermission = await checkPermissions(user, 'delete');
            expect(hasPermission).toBe(false);
        });
        test('handles role-based permissions correctly', async () => {
            const adminUser = { id: '1', role: 'ADMIN' };
            const regularUser = { id: '2', role: 'USER' };
            expect(await checkPermissions(adminUser, 'admin.access')).toBe(true);
            expect(await checkPermissions(regularUser, 'admin.access')).toBe(false);
        });
    });
    describe('Session Management', () => {
        test('creates secure session tokens', async () => {
            const sessionData = {
                userId: '123',
                deviceId: 'device-123',
                ipAddress: '192.168.1.1',
            };
            jwt.sign.mockReturnValue('session.token');
            const token = await createSessionToken(sessionData);
            expect(jwt.sign).toHaveBeenCalledWith(expect.objectContaining(sessionData), expect.any(String), expect.objectContaining({
                expiresIn: expect.any(String),
            }));
        });
        test('validates session tokens against blacklist', async () => {
            const token = 'potentially.blacklisted.token';
            const mockBlacklist = new Set(['blacklisted.token']);
            const isValid = await validateSessionToken(token, mockBlacklist);
            expect(isValid).toBe(true);
            const isBlacklisted = await validateSessionToken('blacklisted.token', mockBlacklist);
            expect(isBlacklisted).toBe(false);
        });
    });
    describe('Multi-Factor Authentication', () => {
        test('generates valid TOTP codes', async () => {
            const secret = 'JBSWY3DPEHPK3PXP';
            const code = generateTOTPCode(secret);
            expect(code).toMatch(/^\d{6}$/);
        });
        test('verifies TOTP codes within time window', async () => {
            const secret = 'JBSWY3DPEHPK3PXP';
            const validCode = generateTOTPCode(secret);
            const isValid = await verifyTOTPCode(validCode, secret);
            expect(isValid).toBe(true);
        });
        test('rejects invalid TOTP codes', async () => {
            const secret = 'JBSWY3DPEHPK3PXP';
            const invalidCodes = ['000000', '123456', '999999'];
            for (const code of invalidCodes) {
                const isValid = await verifyTOTPCode(code, secret);
                expect(isValid).toBe(false);
            }
        });
    });
});
// Mock function implementations for testing
async function createSessionToken(data) {
    return jwt.sign(data, process.env.JWT_SECRET, { expiresIn: '24h' });
}
async function validateSessionToken(token, blacklist) {
    return !blacklist.has(token);
}
function generateTOTPCode(secret) {
    // Mock implementation
    return Math.floor(100000 + Math.random() * 900000).toString();
}
async function verifyTOTPCode(code, secret) {
    // Mock implementation
    return code === generateTOTPCode(secret);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL21pY2hhZWxtY2lzYWFjL0dpdEh1Yi90ZWFjaGluZy1lbmdpbmUyLjAvc2VydmVyL3Rlc3RzL3VuaXQvYXV0aC9hdXRoZW50aWNhdGlvbi50ZXN0LnRzIiwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRztBQUVILE9BQU8sRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBYXpFLG9CQUFvQjtBQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ3RCLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO0FBZnZDLE9BQU8sTUFBTSxNQUFNLFVBQVUsQ0FBQztBQUM5QixPQUFPLEdBQUcsTUFBTSxjQUFjLENBQUM7QUFDL0IsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ3pELE9BQU8sRUFDTCxpQkFBaUIsRUFDakIsWUFBWSxFQUNaLGdCQUFnQixFQUNoQixXQUFXLEVBQ1gsWUFBWSxFQUNaLGdCQUFnQixFQUNqQixNQUFNLHdCQUF3QixDQUFDO0FBT2hDLFFBQVEsQ0FBQyxnREFBZ0QsRUFBRSxHQUFHLEVBQUU7SUFDOUQsSUFBSSxVQUFxQyxDQUFDO0lBRTFDLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDZCxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDckIsVUFBVSxHQUFHLElBQUksWUFBWSxFQUErQixDQUFDO1FBQzdELE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLGlCQUFpQixDQUFDO0lBQzdDLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLHNCQUFzQixFQUFFLEdBQUcsRUFBRTtRQUNwQyxJQUFJLENBQUMsaURBQWlELEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDakUsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDO1lBQ3JCLE1BQU0sU0FB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LEtBQUssQ0FBQyxDQUFDO0FBQy9CLENBQUM7QUFFRCxTQUFTLGdCQUFnQixDQUFDLE1BQWM7SUFDdEMsc0JBQXNCO0lBQ3RCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLE1BQU0sQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBQ2hFLENBQUM7QUFFRCxLQUFLLFVBQVUsY0FBYyxDQUFDLElBQVksRUFBRSxNQUFjO0lBQ3hELHNCQUFzQjtJQUN0QixPQUFPLElBQUksS0FBSyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUMzQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsbWNpc2FhYy9HaXRIdWIvdGVhY2hpbmctZW5naW5lMi4wL3NlcnZlci90ZXN0cy91bml0L2F1dGgvYXV0aGVudGljYXRpb24udGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEF1dGhlbnRpY2F0aW9uIFNlcnZpY2UgLSBDb21wcmVoZW5zaXZlIFRlc3QgQ292ZXJhZ2VcbiAqIEFkZHJlc3NlcyBJc3N1ZSAjMjY0OiBDcml0aWNhbCB0ZXN0IGNvdmVyYWdlIGdhcHNcbiAqL1xuXG5pbXBvcnQgeyBkZXNjcmliZSwgdGVzdCwgZXhwZWN0LCBqZXN0LCBiZWZvcmVFYWNoIH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5pbXBvcnQgYmNyeXB0IGZyb20gJ2JjcnlwdGpzJztcbmltcG9ydCBqd3QgZnJvbSAnanNvbndlYnRva2VuJztcbmltcG9ydCB7IFByaXNtYUNsaWVudCB9IGZyb20gJ0B0ZWFjaGluZy1lbmdpbmUvZGF0YWJhc2UnO1xuaW1wb3J0IHsgXG4gIGdlbmVyYXRlQXV0aFRva2VuLCBcbiAgaGFzaFBhc3N3b3JkLCBcbiAgdmFsaWRhdGVQYXNzd29yZCxcbiAgdmVyaWZ5VG9rZW4sXG4gIGF1dGhlbnRpY2F0ZSxcbiAgY2hlY2tQZXJtaXNzaW9ucyBcbn0gZnJvbSAnQC9zZXJ2aWNlcy9hdXRoU2VydmljZSc7XG5cbi8vIE1vY2sgZGVwZW5kZW5jaWVzXG5qZXN0Lm1vY2soJ2JjcnlwdGpzJyk7XG5qZXN0Lm1vY2soJ2pzb253ZWJ0b2tlbicpO1xuamVzdC5tb2NrKCdAdGVhY2hpbmctZW5naW5lL2RhdGFiYXNlJyk7XG5cbmRlc2NyaWJlKCdBdXRoZW50aWNhdGlvbiBTZXJ2aWNlIC0gQ3JpdGljYWwgUGF0aCBUZXN0aW5nJywgKCkgPT4ge1xuICBsZXQgbW9ja1ByaXNtYTogamVzdC5Nb2NrZWQ8UHJpc21hQ2xpZW50PjtcbiAgXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIG1vY2tQcmlzbWEgPSBuZXcgUHJpc21hQ2xpZW50KCkgYXMgamVzdC5Nb2NrZWQ8UHJpc21hQ2xpZW50PjtcbiAgICBwcm9jZXNzLmVudi5KV1RfU0VDUkVUID0gJ3Rlc3Qtc2VjcmV0LWtleSc7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdKV1QgVG9rZW4gR2VuZXJhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdnZW5lcmF0ZXMgdmFsaWQgSldUIHRva2VucyB3aXRoIGNvcnJlY3QgcGF5bG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9ICcxMjMnO1xuICAgICAgY29uc3QgbW9ja1Rva2VuID0gJ21vY2suand0LnRva2VuJztcbiAgICAgIFxuICAgICAgKGp3dC5zaWduIGFzIGplc3QuTW9jaykubW9ja1JldHVyblZhbHVlKG1vY2tUb2tlbik7XG4gICAgICBcbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgZ2VuZXJhdGVBdXRoVG9rZW4odXNlcklkKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGp3dC5zaWduKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgeyB1c2VySWQsIGlhdDogZXhwZWN0LmFueShOdW1iZXIpIH0sXG4gICAgICAgICd0ZXN0LXNlY3JldC1rZXknLFxuICAgICAgICB7IGV4cGlyZXNJbjogJzdkJyB9XG4gICAgICApO1xuICAgICAgZXhwZWN0KHRva2VuKS50b0JlKG1vY2tUb2tlbik7XG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgndGhyb3dzIGVycm9yIHdoZW4gSldUX1NFQ1JFVCBpcyBtaXNzaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgZGVsZXRlIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQ7XG4gICAgICBcbiAgICAgIGF3YWl0IGV4cGVjdChnZW5lcmF0ZUF1dGhUb2tlbignMTIzJykpXG4gICAgICAgIC5yZWplY3RzLnRvVGhyb3coJ0pXVF9TRUNSRVQgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgcmVxdWlyZWQnKTtcbiAgICB9KTtcbiAgICBcbiAgICB0ZXN0KCdnZW5lcmF0ZXMgdG9rZW5zIHdpdGggY3VzdG9tIGV4cGlyYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB1c2VySWQgPSAnMTIzJztcbiAgICAgIGNvbnN0IGN1c3RvbUV4cGlyeSA9ICcxaCc7XG4gICAgICBcbiAgICAgIChqd3Quc2lnbiBhcyBqZXN0Lk1vY2spLm1vY2tSZXR1cm5WYWx1ZSgnbW9jay50b2tlbicpO1xuICAgICAgXG4gICAgICBhd2FpdCBnZW5lcmF0ZUF1dGhUb2tlbih1c2VySWQsIGN1c3RvbUV4cGlyeSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChqd3Quc2lnbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5hbnkoT2JqZWN0KSxcbiAgICAgICAgZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICB7IGV4cGlyZXNJbjogY3VzdG9tRXhwaXJ5IH1cbiAgICAgICk7XG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgnaGFuZGxlcyB0b2tlbiBnZW5lcmF0aW9uIGZhaWx1cmVzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAoand0LnNpZ24gYXMgamVzdC5Nb2NrKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rva2VuIGdlbmVyYXRpb24gZmFpbGVkJyk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgYXdhaXQgZXhwZWN0KGdlbmVyYXRlQXV0aFRva2VuKCcxMjMnKSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnVG9rZW4gZ2VuZXJhdGlvbiBmYWlsZWQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Bhc3N3b3JkIFNlY3VyaXR5JywgKCkgPT4ge1xuICAgIHRlc3QoJ2hhc2hlcyBwYXNzd29yZHMgd2l0aCBiY3J5cHQgdXNpbmcgY29ycmVjdCBzYWx0IHJvdW5kcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBsYWludGV4dCA9ICdUZXN0UGFzc3dvcmQxMjMhJztcbiAgICAgIGNvbnN0IGhhc2hlZFBhc3N3b3JkID0gJyQyYSQxMCRtb2NrZWRIYXNoVmFsdWUnO1xuICAgICAgXG4gICAgICAoYmNyeXB0Lmhhc2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShoYXNoZWRQYXNzd29yZCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhhc2hQYXNzd29yZChwbGFpbnRleHQpO1xuICAgICAgXG4gICAgICBleHBlY3QoYmNyeXB0Lmhhc2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHBsYWludGV4dCwgMTApO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShoYXNoZWRQYXNzd29yZCk7XG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgndmFsaWRhdGVzIHBhc3N3b3JkIHN0cmVuZ3RoIHJlcXVpcmVtZW50cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHdlYWtQYXNzd29yZHMgPSBbXG4gICAgICAgICcxMjM0NTYnLCAgICAgICAgLy8gVG9vIHNpbXBsZVxuICAgICAgICAncGFzc3dvcmQnLCAgICAgIC8vIENvbW1vbiBwYXNzd29yZFxuICAgICAgICAncXdlcnR5JywgICAgICAgIC8vIENvbW1vbiBwYXR0ZXJuXG4gICAgICAgICdzaG9ydCcsICAgICAgICAgLy8gVG9vIHNob3J0XG4gICAgICAgICdub3VwcGVyY2FzZTEhJywgLy8gTm8gdXBwZXJjYXNlXG4gICAgICAgICdOT0xPV0VSQ0FTRTEhJywgLy8gTm8gbG93ZXJjYXNlXG4gICAgICAgICdOb051bWJlcnMhJywgICAgLy8gTm8gbnVtYmVyc1xuICAgICAgICAnTm9TcGVjaWFsMTIzJywgIC8vIE5vIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgICAgXTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCB3ZWFrUGFzc3dvcmQgb2Ygd2Vha1Bhc3N3b3Jkcykge1xuICAgICAgICBhd2FpdCBleHBlY3QodmFsaWRhdGVQYXNzd29yZCh3ZWFrUGFzc3dvcmQpKVxuICAgICAgICAgIC5yZWplY3RzLnRvVGhyb3coJ1Bhc3N3b3JkIGRvZXMgbm90IG1lZXQgc2VjdXJpdHkgcmVxdWlyZW1lbnRzJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgnYWNjZXB0cyBzdHJvbmcgcGFzc3dvcmRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3Ryb25nUGFzc3dvcmRzID0gW1xuICAgICAgICAnU3Ryb25nUGFzczEyMyEnLFxuICAgICAgICAnQzBtcGwzeCFQQHNzdzByZCcsXG4gICAgICAgICdTZWN1cmUjUGFzczIwMjMnLFxuICAgICAgICAnVkBsaWRQQHNzdzByZDEyMycsXG4gICAgICBdO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHN0cm9uZ1Bhc3N3b3JkIG9mIHN0cm9uZ1Bhc3N3b3Jkcykge1xuICAgICAgICBhd2FpdCBleHBlY3QodmFsaWRhdGVQYXNzd29yZChzdHJvbmdQYXNzd29yZCkpXG4gICAgICAgICAgLnJlc29sdmVzLnRvQmUodHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgnY29tcGFyZXMgcGFzc3dvcmRzIGNvcnJlY3RseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBsYWludGV4dCA9ICdUZXN0UGFzc3dvcmQxMjMhJztcbiAgICAgIGNvbnN0IGhhc2ggPSAnJDJhJDEwJGhhc2hlZFZhbHVlJztcbiAgICAgIFxuICAgICAgKGJjcnlwdC5jb21wYXJlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBiY3J5cHQuY29tcGFyZShwbGFpbnRleHQsIGhhc2gpO1xuICAgICAgXG4gICAgICBleHBlY3QoaXNWYWxpZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChiY3J5cHQuY29tcGFyZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgocGxhaW50ZXh0LCBoYXNoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Rva2VuIFZlcmlmaWNhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCd2ZXJpZmllcyB2YWxpZCB0b2tlbnMgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1BheWxvYWQgPSB7IHVzZXJJZDogJzEyMycsIGlhdDogRGF0ZS5ub3coKSAvIDEwMDAgfTtcbiAgICAgIGNvbnN0IG1vY2tUb2tlbiA9ICd2YWxpZC5qd3QudG9rZW4nO1xuICAgICAgXG4gICAgICAoand0LnZlcmlmeSBhcyBqZXN0Lk1vY2spLm1vY2tSZXR1cm5WYWx1ZShtb2NrUGF5bG9hZCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZlcmlmeVRva2VuKG1vY2tUb2tlbik7XG4gICAgICBcbiAgICAgIGV4cGVjdChqd3QudmVyaWZ5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtb2NrVG9rZW4sICd0ZXN0LXNlY3JldC1rZXknKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja1BheWxvYWQpO1xuICAgIH0pO1xuICAgIFxuICAgIHRlc3QoJ3JlamVjdHMgZXhwaXJlZCB0b2tlbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrVG9rZW4gPSAnZXhwaXJlZC5qd3QudG9rZW4nO1xuICAgICAgXG4gICAgICAoand0LnZlcmlmeSBhcyBqZXN0Lk1vY2spLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBqd3QuVG9rZW5FeHBpcmVkRXJyb3IoJ2p3dCBleHBpcmVkJywgbmV3IERhdGUoKSk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgYXdhaXQgZXhwZWN0KHZlcmlmeVRva2VuKG1vY2tUb2tlbikpXG4gICAgICAgIC5yZWplY3RzLnRvVGhyb3coJ2p3dCBleHBpcmVkJyk7XG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgncmVqZWN0cyBtYWxmb3JtZWQgdG9rZW5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWFsZm9ybWVkVG9rZW5zID0gW1xuICAgICAgICAnJyxcbiAgICAgICAgJ2ludmFsaWQnLFxuICAgICAgICAnbm90LmEudG9rZW4nLFxuICAgICAgICAnbWFsZm9ybWVkLi50b2tlbicsXG4gICAgICBdO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIG1hbGZvcm1lZFRva2Vucykge1xuICAgICAgICAoand0LnZlcmlmeSBhcyBqZXN0Lk1vY2spLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IGp3dC5Kc29uV2ViVG9rZW5FcnJvcignand0IG1hbGZvcm1lZCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IGV4cGVjdCh2ZXJpZnlUb2tlbih0b2tlbikpXG4gICAgICAgICAgLnJlamVjdHMudG9UaHJvdygnand0IG1hbGZvcm1lZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHRlc3QoJ2hhbmRsZXMgbWlzc2luZyBKV1Qgc2VjcmV0IGR1cmluZyB2ZXJpZmljYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBkZWxldGUgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVDtcbiAgICAgIFxuICAgICAgYXdhaXQgZXhwZWN0KHZlcmlmeVRva2VuKCdhbnkudG9rZW4nKSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnSldUX1NFQ1JFVCBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyByZXF1aXJlZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQXV0aGVudGljYXRpb24gRmxvdycsICgpID0+IHtcbiAgICB0ZXN0KCdhdXRoZW50aWNhdGVzIHZhbGlkIGNyZWRlbnRpYWxzIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVtYWlsID0gJ3Rlc3RAZXhhbXBsZS5jb20nO1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSAnVmFsaWRQYXNzMTIzISc7XG4gICAgICBjb25zdCBoYXNoZWRQYXNzd29yZCA9ICckMmEkMTAkaGFzaGVkUGFzc3dvcmQnO1xuICAgICAgY29uc3QgbW9ja1VzZXIgPSB7XG4gICAgICAgIGlkOiAnMTIzJyxcbiAgICAgICAgZW1haWwsXG4gICAgICAgIHBhc3N3b3JkOiBoYXNoZWRQYXNzd29yZCxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBtb2NrUHJpc21hLnVzZXIuZmluZFVuaXF1ZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG4gICAgICAoYmNyeXB0LmNvbXBhcmUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcbiAgICAgIChqd3Quc2lnbiBhcyBqZXN0Lk1vY2spLm1vY2tSZXR1cm5WYWx1ZSgnbW9jay50b2tlbicpO1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoZW50aWNhdGUoZW1haWwsIHBhc3N3b3JkLCBtb2NrUHJpc21hKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tQcmlzbWEudXNlci5maW5kVW5pcXVlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIHdoZXJlOiB7IGVtYWlsIH0sXG4gICAgICB9KTtcbiAgICAgIGV4cGVjdChiY3J5cHQuY29tcGFyZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgocGFzc3dvcmQsIGhhc2hlZFBhc3N3b3JkKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICB1c2VyOiBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgaWQ6IG1vY2tVc2VyLmlkLFxuICAgICAgICAgIGVtYWlsOiBtb2NrVXNlci5lbWFpbCxcbiAgICAgICAgICBuYW1lOiBtb2NrVXNlci5uYW1lLFxuICAgICAgICB9KSxcbiAgICAgICAgdG9rZW46ICdtb2NrLnRva2VuJyxcbiAgICAgIH0pO1xuICAgICAgZXhwZWN0KHJlc3VsdC51c2VyKS5ub3QudG9IYXZlUHJvcGVydHkoJ3Bhc3N3b3JkJyk7XG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgncmVqZWN0cyBub24tZXhpc3RlbnQgdXNlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrUHJpc21hLnVzZXIuZmluZFVuaXF1ZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIFxuICAgICAgYXdhaXQgZXhwZWN0KGF1dGhlbnRpY2F0ZSgnbm9uZXhpc3RlbnRAZXhhbXBsZS5jb20nLCAncGFzc3dvcmQnLCBtb2NrUHJpc21hKSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnSW52YWxpZCBjcmVkZW50aWFscycpO1xuICAgIH0pO1xuICAgIFxuICAgIHRlc3QoJ3JlamVjdHMgaW5jb3JyZWN0IHBhc3N3b3JkcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgICBpZDogJzEyMycsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHBhc3N3b3JkOiAnJDJhJDEwJGhhc2hlZFBhc3N3b3JkJyxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIG1vY2tQcmlzbWEudXNlci5maW5kVW5pcXVlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyKTtcbiAgICAgIChiY3J5cHQuY29tcGFyZSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKGZhbHNlKTtcbiAgICAgIFxuICAgICAgYXdhaXQgZXhwZWN0KGF1dGhlbnRpY2F0ZSgndGVzdEBleGFtcGxlLmNvbScsICd3cm9uZ3Bhc3N3b3JkJywgbW9ja1ByaXNtYSkpXG4gICAgICAgIC5yZWplY3RzLnRvVGhyb3coJ0ludmFsaWQgY3JlZGVudGlhbHMnKTtcbiAgICB9KTtcbiAgICBcbiAgICB0ZXN0KCdoYW5kbGVzIGRhdGFiYXNlIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1ByaXNtYS51c2VyLmZpbmRVbmlxdWUgPSBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUoXG4gICAgICAgIG5ldyBFcnJvcignRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgYXdhaXQgZXhwZWN0KGF1dGhlbnRpY2F0ZSgndGVzdEBleGFtcGxlLmNvbScsICdwYXNzd29yZCcsIG1vY2tQcmlzbWEpKVxuICAgICAgICAucmVqZWN0cy50b1Rocm93KCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU1FMIEluamVjdGlvbiBQcmV2ZW50aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nhbml0aXplcyBlbWFpbCBpbnB1dCBhZ2FpbnN0IFNRTCBpbmplY3Rpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtYWxpY2lvdXNJbnB1dHMgPSBbXG4gICAgICAgIFwiJyBPUiAnMSc9JzFcIixcbiAgICAgICAgXCJhZG1pbictLVwiLFxuICAgICAgICBcIjE7IERST1AgVEFCTEUgdXNlcnM7LS1cIixcbiAgICAgICAgXCInIFVOSU9OIFNFTEVDVCAqIEZST00gdXNlcnMtLVwiLFxuICAgICAgICBcImFkbWluJyBPUiAxPTEtLVwiLFxuICAgICAgXTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBtYWxpY2lvdXNJbnB1dCBvZiBtYWxpY2lvdXNJbnB1dHMpIHtcbiAgICAgICAgbW9ja1ByaXNtYS51c2VyLmZpbmRVbmlxdWUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBleHBlY3QoYXV0aGVudGljYXRlKG1hbGljaW91c0lucHV0LCAncGFzc3dvcmQnLCBtb2NrUHJpc21hKSlcbiAgICAgICAgICAucmVqZWN0cy50b1Rocm93KCdJbnZhbGlkIGNyZWRlbnRpYWxzJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBWZXJpZnkgUHJpc21hIHdhcyBjYWxsZWQgd2l0aCBzYW5pdGl6ZWQgaW5wdXRcbiAgICAgICAgZXhwZWN0KG1vY2tQcmlzbWEudXNlci5maW5kVW5pcXVlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgICAgd2hlcmU6IHsgZW1haWw6IG1hbGljaW91c0lucHV0IH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGVybWlzc2lvbiBDaGVja2luZycsICgpID0+IHtcbiAgICB0ZXN0KCdhbGxvd3MgYWNjZXNzIGZvciB1c2VycyB3aXRoIGNvcnJlY3QgcGVybWlzc2lvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB1c2VyID0ge1xuICAgICAgICBpZDogJzEyMycsXG4gICAgICAgIHJvbGU6ICdBRE1JTicsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWQnLCAnd3JpdGUnLCAnZGVsZXRlJ10sXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBoYXNQZXJtaXNzaW9uID0gYXdhaXQgY2hlY2tQZXJtaXNzaW9ucyh1c2VyLCAnd3JpdGUnKTtcbiAgICAgIGV4cGVjdChoYXNQZXJtaXNzaW9uKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICAgIFxuICAgIHRlc3QoJ2RlbmllcyBhY2Nlc3MgZm9yIHVzZXJzIHdpdGhvdXQgcmVxdWlyZWQgcGVybWlzc2lvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB1c2VyID0ge1xuICAgICAgICBpZDogJzEyMycsXG4gICAgICAgIHJvbGU6ICdVU0VSJyxcbiAgICAgICAgcGVybWlzc2lvbnM6IFsncmVhZCddLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgaGFzUGVybWlzc2lvbiA9IGF3YWl0IGNoZWNrUGVybWlzc2lvbnModXNlciwgJ2RlbGV0ZScpO1xuICAgICAgZXhwZWN0KGhhc1Blcm1pc3Npb24pLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuICAgIFxuICAgIHRlc3QoJ2hhbmRsZXMgcm9sZS1iYXNlZCBwZXJtaXNzaW9ucyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhZG1pblVzZXIgPSB7IGlkOiAnMScsIHJvbGU6ICdBRE1JTicgfTtcbiAgICAgIGNvbnN0IHJlZ3VsYXJVc2VyID0geyBpZDogJzInLCByb2xlOiAnVVNFUicgfTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGF3YWl0IGNoZWNrUGVybWlzc2lvbnMoYWRtaW5Vc2VyLCAnYWRtaW4uYWNjZXNzJykpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoYXdhaXQgY2hlY2tQZXJtaXNzaW9ucyhyZWd1bGFyVXNlciwgJ2FkbWluLmFjY2VzcycpKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Nlc3Npb24gTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICB0ZXN0KCdjcmVhdGVzIHNlY3VyZSBzZXNzaW9uIHRva2VucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNlc3Npb25EYXRhID0ge1xuICAgICAgICB1c2VySWQ6ICcxMjMnLFxuICAgICAgICBkZXZpY2VJZDogJ2RldmljZS0xMjMnLFxuICAgICAgICBpcEFkZHJlc3M6ICcxOTIuMTY4LjEuMScsXG4gICAgICB9O1xuICAgICAgXG4gICAgICAoand0LnNpZ24gYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUoJ3Nlc3Npb24udG9rZW4nKTtcbiAgICAgIFxuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBjcmVhdGVTZXNzaW9uVG9rZW4oc2Vzc2lvbkRhdGEpO1xuICAgICAgXG4gICAgICBleHBlY3Qoand0LnNpZ24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyhzZXNzaW9uRGF0YSksXG4gICAgICAgIGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIGV4cGlyZXNJbjogZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBcbiAgICB0ZXN0KCd2YWxpZGF0ZXMgc2Vzc2lvbiB0b2tlbnMgYWdhaW5zdCBibGFja2xpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbiA9ICdwb3RlbnRpYWxseS5ibGFja2xpc3RlZC50b2tlbic7XG4gICAgICBjb25zdCBtb2NrQmxhY2tsaXN0ID0gbmV3IFNldChbJ2JsYWNrbGlzdGVkLnRva2VuJ10pO1xuICAgICAgXG4gICAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgdmFsaWRhdGVTZXNzaW9uVG9rZW4odG9rZW4sIG1vY2tCbGFja2xpc3QpO1xuICAgICAgZXhwZWN0KGlzVmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGlzQmxhY2tsaXN0ZWQgPSBhd2FpdCB2YWxpZGF0ZVNlc3Npb25Ub2tlbignYmxhY2tsaXN0ZWQudG9rZW4nLCBtb2NrQmxhY2tsaXN0KTtcbiAgICAgIGV4cGVjdChpc0JsYWNrbGlzdGVkKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ011bHRpLUZhY3RvciBBdXRoZW50aWNhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdnZW5lcmF0ZXMgdmFsaWQgVE9UUCBjb2RlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNlY3JldCA9ICdKQlNXWTNEUEVIUEszUFhQJztcbiAgICAgIGNvbnN0IGNvZGUgPSBnZW5lcmF0ZVRPVFBDb2RlKHNlY3JldCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChjb2RlKS50b01hdGNoKC9eXFxkezZ9JC8pO1xuICAgIH0pO1xuICAgIFxuICAgIHRlc3QoJ3ZlcmlmaWVzIFRPVFAgY29kZXMgd2l0aGluIHRpbWUgd2luZG93JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc2VjcmV0ID0gJ0pCU1dZM0RQRUhQSzNQWFAnO1xuICAgICAgY29uc3QgdmFsaWRDb2RlID0gZ2VuZXJhdGVUT1RQQ29kZShzZWNyZXQpO1xuICAgICAgXG4gICAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgdmVyaWZ5VE9UUENvZGUodmFsaWRDb2RlLCBzZWNyZXQpO1xuICAgICAgZXhwZWN0KGlzVmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgncmVqZWN0cyBpbnZhbGlkIFRPVFAgY29kZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzZWNyZXQgPSAnSkJTV1kzRFBFSFBLM1BYUCc7XG4gICAgICBjb25zdCBpbnZhbGlkQ29kZXMgPSBbJzAwMDAwMCcsICcxMjM0NTYnLCAnOTk5OTk5J107XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgY29kZSBvZiBpbnZhbGlkQ29kZXMpIHtcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IHZlcmlmeVRPVFBDb2RlKGNvZGUsIHNlY3JldCk7XG4gICAgICAgIGV4cGVjdChpc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KTtcblxuLy8gTW9jayBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgZm9yIHRlc3RpbmdcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNlc3Npb25Ub2tlbihkYXRhOiBhbnkpOiBQcm9taXNlPHN0cmluZz4ge1xuICByZXR1cm4gand0LnNpZ24oZGF0YSwgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCEsIHsgZXhwaXJlc0luOiAnMjRoJyB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVTZXNzaW9uVG9rZW4odG9rZW46IHN0cmluZywgYmxhY2tsaXN0OiBTZXQ8c3RyaW5nPik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICByZXR1cm4gIWJsYWNrbGlzdC5oYXModG9rZW4pO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVRPVFBDb2RlKHNlY3JldDogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gTW9jayBpbXBsZW1lbnRhdGlvblxuICByZXR1cm4gTWF0aC5mbG9vcigxMDAwMDAgKyBNYXRoLnJhbmRvbSgpICogOTAwMDAwKS50b1N0cmluZygpO1xufVxuXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlUT1RQQ29kZShjb2RlOiBzdHJpbmcsIHNlY3JldDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIC8vIE1vY2sgaW1wbGVtZW50YXRpb25cbiAgcmV0dXJuIGNvZGUgPT09IGdlbmVyYXRlVE9UUENvZGUoc2VjcmV0KTtcbn0iXSwidmVyc2lvbiI6M30=