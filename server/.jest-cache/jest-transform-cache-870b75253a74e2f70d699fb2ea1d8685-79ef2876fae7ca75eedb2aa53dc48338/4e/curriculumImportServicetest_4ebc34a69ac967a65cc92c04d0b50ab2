982223a89ec909aa09573aa81cd991b3
import { describe, test, expect, beforeEach, jest } from '@jest/globals';
// Mock external services
jest.mock('../../src/services/embeddingService', () => ({
    embeddingService: {
        generateEmbedding: jest.fn().mockResolvedValue([0.1, 0.2, 0.3]),
        generateBatchEmbeddings: jest.fn().mockResolvedValue([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]),
    },
}));
jest.mock('../../src/services/clusteringService', () => ({
    clusteringService: {
        clusterExpectations: jest.fn().mockResolvedValue([
            {
                clusterName: 'Number Operations',
                clusterType: 'concept',
                expectationIds: ['exp1', 'exp2'],
                confidence: 0.85,
            },
        ]),
    },
}));
import { CurriculumImportService } from '../../src/services/curriculumImportService';
import { prisma } from '../../src/prisma';
const mockPrisma = prisma;
describe('CurriculumImportService', () => {
    let curriculumImportService;
    beforeEach(() => {
        jest.clearAllMocks();
        curriculumImportService = new CurriculumImportService();
    });
    describe.skip('createImport', () => {
        test('should create new curriculum import', async () => {
            const userId = 1;
            const importData = {
                filename: 'test-curriculum.pdf',
                originalName: 'Grade 1 Math Curriculum.pdf',
                grade: 1,
                subject: 'Mathematics',
            };
            const mockImport = {
                id: 'import1',
                userId,
                ...importData,
                status: 'UPLOADING',
                createdAt: new Date(),
            };
            mockPrisma.curriculumImport.create.mockResolvedValue(mockImport);
            const result = await curriculumImportService.createImport(userId, importData);
            expect(result).toEqual(mockImport);
            expect(mockPrisma.curriculumImport.create).toHaveBeenCalledWith({
                data: {
                    userId,
                    ...importData,
                    status: 'UPLOADING',
                },
            });
        });
    });
    describe.skip('updateImportStatus', () => {
        test('should update import status and metadata', async () => {
            const importId = 'import1';
            const status = 'PROCESSING';
            const metadata = { step: 'parsing_pdf' };
            const mockUpdatedImport = {
                id: importId,
                status,
                metadata,
                updatedAt: new Date(),
            };
            mockPrisma.curriculumImport.update.mockResolvedValue(mockUpdatedImport);
            // @ts-ignore - method doesn't exist in current implementation
            const result = await curriculumImportService.updateImportStatus(importId, status, metadata);
            expect(result).toEqual(mockUpdatedImport);
            expect(mockPrisma.curriculumImport.update).toHaveBeenCalledWith({
                where: { id: importId },
                data: {
                    status,
                    metadata,
                    updatedAt: expect.any(Date),
                },
            });
        });
        test('should handle processing completion', async () => {
            const importId = 'import1';
            const status = 'COMPLETED';
            mockPrisma.curriculumImport.update.mockResolvedValue({
                id: importId,
                status,
                processedAt: expect.any(Date),
                completedAt: expect.any(Date),
            });
            await curriculumImportService.updateImportStatus(importId, status);
            expect(mockPrisma.curriculumImport.update).toHaveBeenCalledWith({
                where: { id: importId },
                data: {
                    status,
                    processedAt: expect.any(Date),
                    completedAt: expect.any(Date),
                    updatedAt: expect.any(Date),
                },
            });
        });
    });
    describe.skip('parseTextContent', () => {
        test('should parse curriculum text into structured expectations', async () => {
            const importId = 'import1';
            const rawText = `
        A1.1 - Students will demonstrate understanding of numbers 1-10
        A1.2 - Students will count objects accurately up to 20
        B2.1 - Students will identify and extend simple patterns
      `;
            const mockImport = {
                id: importId,
                grade: 1,
                subject: 'Mathematics',
            };
            mockPrisma.curriculumImport.findUnique.mockResolvedValue(mockImport);
            mockPrisma.curriculumImport.update.mockResolvedValue({});
            mockPrisma.$transaction.mockImplementation(async (callback) => {
                return await callback(mockPrisma);
            });
            mockPrisma.curriculumExpectation.createMany.mockResolvedValue({ count: 3 });
            const result = await curriculumImportService.parseTextContent(importId, rawText);
            expect(result.processedCount).toBe(3);
            expect(result.expectations).toHaveLength(3);
            expect(result.expectations[0].code).toBe('A1.1');
            expect(result.expectations[0].description).toBe('Students will demonstrate understanding of numbers 1-10');
            expect(result.expectations[1].code).toBe('A1.2');
            expect(result.expectations[2].code).toBe('B2.1');
        });
        test('should handle malformed text gracefully', async () => {
            const importId = 'import1';
            const rawText = `
        Invalid line without proper format
        A1.1 - Valid expectation
        Another invalid line
      `;
            const mockImport = {
                id: importId,
                grade: 1,
                subject: 'Mathematics',
            };
            mockPrisma.curriculumImport.findUnique.mockResolvedValue(mockImport);
            mockPrisma.curriculumImport.update.mockResolvedValue({});
            mockPrisma.$transaction.mockImplementation(async (callback) => {
                return await callback(mockPrisma);
            });
            mockPrisma.curriculumExpectation.createMany.mockResolvedValue({ count: 1 });
            const result = await curriculumImportService.parseTextContent(importId, rawText);
            expect(result.processedCount).toBe(1);
            expect(result.expectations).toHaveLength(1);
            expect(result.expectations[0].code).toBe('A1.1');
            expect(result.errors).toHaveLength(2); // Two invalid lines
        });
    });
    describe('processCSVContent', () => {
        test('should parse CSV curriculum data', async () => {
            const importId = 'import1';
            const csvContent = `code,description,strand,substrand,grade,subject
A1.1,"Students will demonstrate understanding of numbers 1-10","Number Sense","Counting",1,"Mathematics"
A1.2,"Students will count objects accurately up to 20","Number Sense","Counting",1,"Mathematics"
B2.1,"Students will identify and extend simple patterns","Patterns","Simple Patterns",1,"Mathematics"`;
            const mockImport = {
                id: importId,
                grade: 1,
                subject: 'Mathematics',
            };
            mockPrisma.curriculumImport.findUnique.mockResolvedValue(mockImport);
            mockPrisma.curriculumImport.update.mockResolvedValue({});
            mockPrisma.$transaction.mockImplementation(async (callback) => {
                return await callback(mockPrisma);
            });
            mockPrisma.curriculumExpectation.createMany.mockResolvedValue({ count: 3 });
            const result = await curriculumImportService.processCSVContent(importId, csvContent);
            expect(result.processedCount).toBe(3);
            expect(result.expectations).toHaveLength(3);
            expect(result.expectations[0].strand).toBe('Number Sense');
            expect(result.expectations[0].substrand).toBe('Counting');
            expect(result.expectations[2].strand).toBe('Patterns');
        });
        test('should handle missing required columns', async () => {
            const importId = 'import1';
            const csvContent = `description,strand
"Students will demonstrate understanding of numbers 1-10","Number Sense"`;
            const mockImport = {
                id: importId,
                grade: 1,
                subject: 'Mathematics',
            };
            mockPrisma.curriculumImport.findUnique.mockResolvedValue(mockImport);
            await expect(curriculumImportService.processCSVContent(importId, csvContent)).rejects.toThrow('Missing required columns');
        });
    });
    describe('generateClusters', () => {
        test('should create expectation clusters using AI', async () => {
            const importId = 'import1';
            const mockExpectations = [
                {
                    id: 'exp1',
                    code: 'A1.1',
                    description: 'Number recognition',
                    strand: 'Number Sense',
                },
                {
                    id: 'exp2',
                    code: 'A1.2',
                    description: 'Counting objects',
                    strand: 'Number Sense',
                },
            ];
            mockPrisma.curriculumExpectation.findMany.mockResolvedValue(mockExpectations);
            mockPrisma.expectationCluster.createMany.mockResolvedValue({ count: 1 });
            mockPrisma.curriculumImport.update.mockResolvedValue({});
            const result = await curriculumImportService.generateClusters(importId);
            expect(result.clustersCreated).toBe(1);
            expect(result.clusters).toHaveLength(1);
            expect(result.clusters[0].clusterName).toBe('Number Operations');
            expect(result.clusters[0].expectationIds).toEqual(['exp1', 'exp2']);
        });
        test('should handle empty expectations', async () => {
            const importId = 'import1';
            mockPrisma.curriculumExpectation.findMany.mockResolvedValue([]);
            const result = await curriculumImportService.generateClusters(importId);
            expect(result.clustersCreated).toBe(0);
            expect(result.clusters).toHaveLength(0);
        });
    });
    describe('getImportProgress', () => {
        test('should return detailed import progress', async () => {
            const importId = 'import1';
            const mockImport = {
                id: importId,
                status: 'PROCESSING',
                totalOutcomes: 100,
                processedOutcomes: 75,
                errorLog: [
                    { line: 10, error: 'Invalid format' },
                    { line: 25, error: 'Missing code' },
                ],
                createdAt: new Date('2024-01-01'),
                updatedAt: new Date('2024-01-02'),
            };
            mockPrisma.curriculumImport.findUnique.mockResolvedValue(mockImport);
            const result = await curriculumImportService.getImportProgress(importId);
            expect(result).toEqual({
                id: importId,
                status: 'PROCESSING',
                progress: 75, // processedOutcomes / totalOutcomes * 100
                totalOutcomes: 100,
                processedOutcomes: 75,
                errorCount: 2,
                errors: mockImport.errorLog,
                createdAt: mockImport.createdAt,
                updatedAt: mockImport.updatedAt,
            });
        });
        test('should handle import not found', async () => {
            const importId = 'nonexistent';
            mockPrisma.curriculumImport.findUnique.mockResolvedValue(null);
            await expect(curriculumImportService.getImportProgress(importId)).rejects.toThrow('Import not found');
        });
    });
    describe('getUserImports', () => {
        test('should return user imports with statistics', async () => {
            const userId = 1;
            const mockImports = [
                {
                    id: 'import1',
                    filename: 'grade1-math.pdf',
                    status: 'COMPLETED',
                    grade: 1,
                    subject: 'Mathematics',
                    totalOutcomes: 50,
                    processedOutcomes: 50,
                    createdAt: new Date('2024-01-01'),
                    curriculumExpectations: [{ id: 'exp1' }, { id: 'exp2' }],
                    clusters: [{ id: 'cluster1' }],
                },
                {
                    id: 'import2',
                    filename: 'grade1-science.pdf',
                    status: 'PROCESSING',
                    grade: 1,
                    subject: 'Science',
                    totalOutcomes: 30,
                    processedOutcomes: 20,
                    createdAt: new Date('2024-01-02'),
                    curriculumExpectations: [{ id: 'exp3' }],
                    clusters: [],
                },
            ];
            mockPrisma.curriculumImport.findMany.mockResolvedValue(mockImports);
            const result = await curriculumImportService.getUserImports(userId);
            expect(result).toHaveLength(2);
            expect(result[0].id).toBe('import1');
            expect(result[0].expectationCount).toBe(2);
            expect(result[0].clusterCount).toBe(1);
            expect(result[1].id).toBe('import2');
            expect(result[1].expectationCount).toBe(1);
            expect(result[1].clusterCount).toBe(0);
        });
    });
    describe('validateImportData', () => {
        test('should validate required fields', () => {
            const validData = {
                filename: 'test.pdf',
                grade: 1,
                subject: 'Mathematics',
            };
            expect(() => curriculumImportService.validateImportData(validData)).not.toThrow();
        });
        test('should reject invalid grade', () => {
            const invalidData = {
                filename: 'test.pdf',
                grade: 15, // Invalid grade
                subject: 'Mathematics',
            };
            expect(() => curriculumImportService.validateImportData(invalidData))
                .toThrow('Grade must be between 1 and 12');
        });
        test('should reject missing filename', () => {
            const invalidData = {
                grade: 1,
                subject: 'Mathematics',
            };
            expect(() => curriculumImportService.validateImportData(invalidData))
                .toThrow('Filename is required');
        });
        test('should reject unsupported file type', () => {
            const invalidData = {
                filename: 'test.txt', // Unsupported extension
                grade: 1,
                subject: 'Mathematics',
            };
            expect(() => curriculumImportService.validateImportData(invalidData))
                .toThrow('Unsupported file type');
        });
    });
    describe('error handling', () => {
        test('should handle database errors during import creation', async () => {
            const userId = 1;
            const importData = {
                filename: 'test.pdf',
                grade: 1,
                subject: 'Mathematics',
            };
            mockPrisma.curriculumImport.create.mockRejectedValue(new Error('Database connection failed'));
            await expect(curriculumImportService.createImport(userId, importData)).rejects.toThrow('Database connection failed');
        });
        test('should handle transaction failures during parsing', async () => {
            const importId = 'import1';
            const rawText = 'A1.1 - Test expectation';
            const mockImport = {
                id: importId,
                grade: 1,
                subject: 'Mathematics',
            };
            mockPrisma.curriculumImport.findUnique.mockResolvedValue(mockImport);
            mockPrisma.$transaction.mockRejectedValue(new Error('Transaction failed'));
            await expect(curriculumImportService.parseTextContent(importId, rawText)).rejects.toThrow('Transaction failed');
        });
        test.skip('should update import status to FAILED on error', async () => {
            const importId = 'import1';
            const errorMessage = 'Processing failed';
            // @ts-ignore - method doesn't exist in current implementation
            await curriculumImportService.markImportAsFailed(importId, errorMessage);
            expect(mockPrisma.curriculumImport.update).toHaveBeenCalledWith({
                where: { id: importId },
                data: {
                    status: 'FAILED',
                    errorMessage,
                    updatedAt: expect.any(Date),
                },
            });
        });
    });
    describe('performance optimization', () => {
        test('should batch process large datasets', async () => {
            const importId = 'import1';
            const largeText = Array.from({ length: 1000 }, (_, i) => `A${i}.1 - Test expectation ${i}`).join('\n');
            const mockImport = {
                id: importId,
                grade: 1,
                subject: 'Mathematics',
            };
            mockPrisma.curriculumImport.findUnique.mockResolvedValue(mockImport);
            mockPrisma.curriculumImport.update.mockResolvedValue({});
            mockPrisma.$transaction.mockImplementation(async (callback) => {
                return await callback(mockPrisma);
            });
            mockPrisma.curriculumExpectation.createMany.mockResolvedValue({ count: 1000 });
            const result = await curriculumImportService.parseTextContent(importId, largeText);
            expect(result.processedCount).toBe(1000);
            expect(result.expectations).toHaveLength(1000);
            // Should have called createMany to batch insert
            expect(mockPrisma.curriculumExpectation.createMany).toHaveBeenCalled();
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL21pY2hhZWxtY2lzYWFjL0dpdEh1Yi90ZWFjaGluZy1lbmdpbmUyLjAvc2VydmVyL3Rlc3RzL3VuaXQvY3VycmljdWx1bUltcG9ydFNlcnZpY2UudGVzdC50cyIsIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUl6RSx5QkFBeUI7QUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQyxxQ0FBcUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQ3RELGdCQUFnQixFQUFFO1FBQ2hCLGlCQUFpQixFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDL0QsdUJBQXVCLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0tBQ3pGO0NBQ0YsQ0FBQyxDQUFDLENBQUM7QUFFSixJQUFJLENBQUMsSUFBSSxDQUFDLHNDQUFzQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDdkQsaUJBQWlCLEVBQUU7UUFDakIsbUJBQW1CLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGlCQUFpQixDQUFDO1lBQy9DO2dCQUNFLFdBQVcsRUFBRSxtQkFBbUI7Z0JBQ2hDLFdBQVcsRUFBRSxTQUFTO2dCQUN0QixjQUFjLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDO2dCQUNoQyxVQUFVLEVBQUUsSUFBSTthQUNqQjtTQUNGLENBQUM7S0FDSDtDQUNGLENBQUMsQ0FBQyxDQUFDO0FBdEJKLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLDRDQUE0QyxDQUFDO0FBQ3JGLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQXVCMUMsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDO0FBRTFCLFFBQVEsQ0FBQyx5QkFBeUIsRUFBRSxHQUFHLEVBQUU7SUFDdkMsSUFBSSx1QkFBZ0QsQ0FBQztJQUVyRCxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2QsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3JCLHVCQUF1QixHQUFHLElBQUksdUJBQXVCLEVBQUUsQ0FBQztJQUMxRCxDQUFDLENBQUMsQ0FBQztJQUVILFFBQVEsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLEdBQUcsRUFBRTtRQUNqQyxJQUFJLENBQUMscUNBQXFDLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDckQsTUFBTSxNQUFNLEdBQUcsQ0FBQyxDQUFDO1lBQ2pCLE1BQU0sVUFBVSxHQUFHO2dCQUNqQixRQUFRLEVBQUUscUJBQXFCO2dCQUMvQixZQUFZLEVBQUUsNkJBQTZCO2dCQUMzQyxLQUFLLEVBQUUsQ0FBQztnQkFDUixPQUFPLEVBQUUsYUFBYTthQUN2QixDQUFDO1lBRUYsTUFBTSxVQUFVLEdBQUc7Z0JBQ2pCLEVBQUUsRUFBRSxTQUFTO2dCQUNiLE1BQU07Z0JBQ04sR0FBRyxVQUFVO2dCQUNiLE1BQU0sRUFBRSxXQUFXO2dCQUNuQixTQUFTLEVBQUUsSUFBSSxJQUFJLEVBQUU7YUFDdEIsQ0FBQztZQUVGLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsVUFBaUIsQ0FBQyxDQUFDO1lBRXhFLE1BQU0sTUFBTSxHQUFHLE1BQU0sdUJBQXVCLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztZQUU5RSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ25DLE1BQU0sQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLENBQUMsb0JBQW9CLENBQUM7Z0JBQzlELElBQUksRUFBRTtvQkFDSixNQUFNO29CQUNOLEdBQUcsVUFBVTtvQkFDYixNQUFNLEVBQUUsV0FBVztpQkFDcEI7YUFDRixDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxHQUFHLEVBQUU7UUFDdkMsSUFBSSxDQUFDLDBDQUEwQyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQzFELE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQztZQUMzQixNQUFNLE1BQU0sR0FBRyxZQUFZLENBQUM7WUFDNUIsTUFBTSxRQUFRLEdBQUcsRUFBRSxJQUFJLEVBQUUsYUFBYSxFQUFFLENBQUM7WUFFekMsTUFBTSxpQkFBaUIsR0FBRztnQkFDeEIsRUFBRSxFQUFFLFFBQVE7Z0JBQ1osTUFBTTtnQkFDTixRQUFRO2dCQUNSLFNBQVMsRUFBRSxJQUFJLElBQUksRUFBRTthQUN0QixDQUFDO1lBRUYsVUFBVSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxpQkFBd0IsQ0FBQyxDQUFDO1lBRS9FLDhEQUE4RDtZQUM5RCxNQUFNLE1BQU0sR0FBRyxNQUFNLHVCQUF1QixDQUFDLGtCQUFrQixDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFFNUYsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1lBQzFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLENBQUMsb0JBQW9CLENBQUM7Z0JBQzlELEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRSxRQUFRLEVBQUU7Z0JBQ3ZCLElBQUksRUFBRTtvQkFDSixNQUFNO29CQUNOLFFBQVE7b0JBQ1IsU0FBUyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO2lCQUM1QjthQUNGLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLHFDQUFxQyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ3JELE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQztZQUMzQixNQUFNLE1BQU0sR0FBRyxXQUFXLENBQUM7WUFFM0IsVUFBVSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQztnQkFDbkQsRUFBRSxFQUFFLFFBQVE7Z0JBQ1osTUFBTTtnQkFDTixXQUFXLEVBQUUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUM7Z0JBQzdCLFdBQVcsRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQzthQUN2QixDQUFDLENBQUM7WUFFVixNQUFNLHVCQUF1QixDQUFDLGtCQUFrQixDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztZQUVuRSxNQUFNLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDLG9CQUFvQixDQUFDO2dCQUM5RCxLQUFLLEVBQUUsRUFBRSxFQUFFLEVBQUUsUUFBUSxFQUFFO2dCQUN2QixJQUFJLEVBQUU7b0JBQ0osTUFBTTtvQkFDTixXQUFXLEVBQUUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUM7b0JBQzdCLFdBQVcsRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztvQkFDN0IsU0FBUyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO2lCQUM1QjthQUNGLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsSUFBSSxDQUFDLGtCQUFrQixFQUFFLEdBQUcsRUFBRTtRQUNyQyxJQUFJLENBQUMsMkRBQTJELEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDM0UsTUFBTSxRQUFRLEdBQUcsU0FBUyxDQUFDO1lBQzNCLE1BQU0sT0FBTyxHQUFHOzs7O09BSWYsQ0FBQztZQUVGLE1BQU0sVUFBVSxHQUFHO2dCQUNqQixFQUFFLEVBQUUsUUFBUTtnQkFDWixLQUFLLEVBQUUsQ0FBQztnQkFDUixPQUFPLEVBQUUsYUFBYTthQUN2QixDQUFDO1lBRUYsVUFBVSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxVQUFpQixDQUFDLENBQUM7WUFDNUUsVUFBVSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxFQUFTLENBQUMsQ0FBQztZQUNoRSxVQUFVLENBQUMsWUFBWSxDQUFDLGtCQUFrQixDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsRUFBRTtnQkFDNUQsT0FBTyxNQUFNLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUNwQyxDQUFDLENBQUMsQ0FBQztZQUNILFVBQVUsQ0FBQyxxQkFBcUIsQ0FBQyxVQUFVLENBQUMsaUJBQWlCLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFTLENBQUMsQ0FBQztZQUVuRixNQUFNLE1BQU0sR0FBRyxNQUFNLHVCQUF1QixDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUVqRixNQUFNLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0QyxNQUFNLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1QyxNQUFNLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDakQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLHlEQUF5RCxDQUFDLENBQUM7WUFDM0csTUFBTSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2pELE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNuRCxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyx5Q0FBeUMsRUFBRSxLQUFLLElBQUksRUFBRTtZQUN6RCxNQUFNLFFBQVEsR0FBRyxTQUFTLENBQUM7WUFDM0IsTUFBTSxPQUFPLEdBQUc7Ozs7T0FJZixDQUFDO1lBRUYsTUFBTSxVQUFVLEdBQUc7Z0JBQ2pCLEVBQUUsRUFBRSxRQUFRO2dCQUNaLEtBQUssRUFBRSxDQUFDO2dCQUNSLE9BQU8sRUFBRSxhQUFhO2FBQ3ZCLENBQUM7WUFFRixVQUFVLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLGlCQUFpQixDQUFDLFVBQWlCLENBQUMsQ0FBQztZQUM1RSxVQUFVLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLEVBQVMsQ0FBQyxDQUFDO1lBQ2hFLFVBQVUsQ0FBQyxZQUFZLENBQUMsa0JBQWtCLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxFQUFFO2dCQUM1RCxPQUFPLE1BQU0sUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ3BDLENBQUMsQ0FBQyxDQUFDO1lBQ0gsVUFBVSxDQUFDLHFCQUFxQixDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQVMsQ0FBQyxDQUFDO1lBRW5GLE1BQU0sTUFBTSxHQUFHLE1BQU0sdUJBQXVCLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBRWpGLE1BQU0sQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RDLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVDLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNqRCxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLG9CQUFvQjtRQUM3RCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLG1CQUFtQixFQUFFLEdBQUcsRUFBRTtRQUNqQyxJQUFJLENBQUMsa0NBQWtDLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDbEQsTUFBTSxRQUFRLEdBQUcsU0FBUyxDQUFDO1lBQzNCLE1BQU0sVUFBVSxHQUFHOzs7c0dBRzZFLENBQUM7WUFFakcsTUFBTSxVQUFVLEdBQUc7Z0JBQ2pCLEVBQUUsRUFBRSxRQUFRO2dCQUNaLEtBQUssRUFBRSxDQUFDO2dCQUNSLE9BQU8sRUFBRSxhQUFhO2FBQ3ZCLENBQUM7WUFFRixVQUFVLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLGlCQUFpQixDQUFDLFVBQWlCLENBQUMsQ0FBQztZQUM1RSxVQUFVLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLEVBQVMsQ0FBQyxDQUFDO1lBQ2hFLFVBQVUsQ0FBQyxZQUFZLENBQUMsa0JBQWtCLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxFQUFFO2dCQUM1RCxPQUFPLE1BQU0sUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ3BDLENBQUMsQ0FBQyxDQUFDO1lBQ0gsVUFBVSxDQUFDLHFCQUFxQixDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQVMsQ0FBQyxDQUFDO1lBRW5GLE1BQU0sTUFBTSxHQUFHLE1BQU0sdUJBQXVCLENBQUMsaUJBQWlCLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1lBRXJGLE1BQU0sQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RDLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVDLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUMzRCxNQUFNLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDMUQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3pELENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLHdDQUF3QyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ3hELE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQztZQUMzQixNQUFNLFVBQVUsR0FBRzt5RUFDZ0QsQ0FBQztZQUVwRSxNQUFNLFVBQVUsR0FBRztnQkFDakIsRUFBRSxFQUFFLFFBQVE7Z0JBQ1osS0FBSyxFQUFFLENBQUM7Z0JBQ1IsT0FBTyxFQUFFLGFBQWE7YUFDdkIsQ0FBQztZQUVGLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsaUJBQWlCLENBQUMsVUFBaUIsQ0FBQyxDQUFDO1lBRTVFLE1BQU0sTUFBTSxDQUNWLHVCQUF1QixDQUFDLGlCQUFpQixDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FDaEUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLDBCQUEwQixDQUFDLENBQUM7UUFDaEQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztJQUVILFFBQVEsQ0FBQyxrQkFBa0IsRUFBRSxHQUFHLEVBQUU7UUFDaEMsSUFBSSxDQUFDLDZDQUE2QyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQzdELE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQztZQUUzQixNQUFNLGdCQUFnQixHQUFHO2dCQUN2QjtvQkFDRSxFQUFFLEVBQUUsTUFBTTtvQkFDVixJQUFJLEVBQUUsTUFBTTtvQkFDWixXQUFXLEVBQUUsb0JBQW9CO29CQUNqQyxNQUFNLEVBQUUsY0FBYztpQkFDdkI7Z0JBQ0Q7b0JBQ0UsRUFBRSxFQUFFLE1BQU07b0JBQ1YsSUFBSSxFQUFFLE1BQU07b0JBQ1osV0FBVyxFQUFFLGtCQUFrQjtvQkFDL0IsTUFBTSxFQUFFLGNBQWM7aUJBQ3ZCO2FBQ0YsQ0FBQztZQUVGLFVBQVUsQ0FBQyxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsZ0JBQXVCLENBQUMsQ0FBQztZQUNyRixVQUFVLENBQUMsa0JBQWtCLENBQUMsVUFBVSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBUyxDQUFDLENBQUM7WUFDaEYsVUFBVSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxFQUFTLENBQUMsQ0FBQztZQUVoRSxNQUFNLE1BQU0sR0FBRyxNQUFNLHVCQUF1QixDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRXhFLE1BQU0sQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZDLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3hDLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1lBQ2pFLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ3RFLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLGtDQUFrQyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ2xELE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQztZQUUzQixVQUFVLENBQUMscUJBQXFCLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBRWhFLE1BQU0sTUFBTSxHQUFHLE1BQU0sdUJBQXVCLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFeEUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztJQUVILFFBQVEsQ0FBQyxtQkFBbUIsRUFBRSxHQUFHLEVBQUU7UUFDakMsSUFBSSxDQUFDLHdDQUF3QyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ3hELE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQztZQUUzQixNQUFNLFVBQVUsR0FBRztnQkFDakIsRUFBRSxFQUFFLFFBQVE7Z0JBQ1osTUFBTSxFQUFFLFlBQVk7Z0JBQ3BCLGFBQWEsRUFBRSxHQUFHO2dCQUNsQixpQkFBaUIsRUFBRSxFQUFFO2dCQUNyQixRQUFRLEVBQUU7b0JBQ1IsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxnQkFBZ0IsRUFBRTtvQkFDckMsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxjQUFjLEVBQUU7aUJBQ3BDO2dCQUNELFNBQVMsRUFBRSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUM7Z0JBQ2pDLFNBQVMsRUFBRSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUM7YUFDbEMsQ0FBQztZQUVGLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsaUJBQWlCLENBQUMsVUFBaUIsQ0FBQyxDQUFDO1lBRTVFLE1BQU0sTUFBTSxHQUFHLE1BQU0sdUJBQXVCLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFekUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQztnQkFDckIsRUFBRSxFQUFFLFFBQVE7Z0JBQ1osTUFBTSxFQUFFLFlBQVk7Z0JBQ3BCLFFBQVEsRUFBRSxFQUFFLEVBQUUsMENBQTBDO2dCQUN4RCxhQUFhLEVBQUUsR0FBRztnQkFDbEIsaUJBQWlCLEVBQUUsRUFBRTtnQkFDckIsVUFBVSxFQUFFLENBQUM7Z0JBQ2IsTUFBTSxFQUFFLFVBQVUsQ0FBQyxRQUFRO2dCQUMzQixTQUFTLEVBQUUsVUFBVSxDQUFDLFNBQVM7Z0JBQy9CLFNBQVMsRUFBRSxVQUFVLENBQUMsU0FBUzthQUNoQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxnQ0FBZ0MsRUFBRSxLQUFLLElBQUksRUFBRTtZQUNoRCxNQUFNLFFBQVEsR0FBRyxhQUFhLENBQUM7WUFFL0IsVUFBVSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUUvRCxNQUFNLE1BQU0sQ0FDVix1QkFBdUIsQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsQ0FDcEQsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFDeEMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztJQUVILFFBQVEsQ0FBQyxnQkFBZ0IsRUFBRSxHQUFHLEVBQUU7UUFDOUIsSUFBSSxDQUFDLDRDQUE0QyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQzVELE1BQU0sTUFBTSxHQUFHLENBQUMsQ0FBQztZQUVqQixNQUFNLFdBQVcsR0FBRztnQkFDbEI7b0JBQ0UsRUFBRSxFQUFFLFNBQVM7b0JBQ2IsUUFBUSxFQUFFLGlCQUFpQjtvQkFDM0IsTUFBTSxFQUFFLFdBQVc7b0JBQ25CLEtBQUssRUFBRSxDQUFDO29CQUNSLE9BQU8sRUFBRSxhQUFhO29CQUN0QixhQUFhLEVBQUUsRUFBRTtvQkFDakIsaUJBQWlCLEVBQUUsRUFBRTtvQkFDckIsU0FBUyxFQUFFLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQztvQkFDakMsc0JBQXNCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQztvQkFDeEQsUUFBUSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsVUFBVSxFQUFFLENBQUM7aUJBQy9CO2dCQUNEO29CQUNFLEVBQUUsRUFBRSxTQUFTO29CQUNiLFFBQVEsRUFBRSxvQkFBb0I7b0JBQzlCLE1BQU0sRUFBRSxZQUFZO29CQUNwQixLQUFLLEVBQUUsQ0FBQztvQkFDUixPQUFPLEVBQUUsU0FBUztvQkFDbEIsYUFBYSxFQUFFLEVBQUU7b0JBQ2pCLGlCQUFpQixFQUFFLEVBQUU7b0JBQ3JCLFNBQVMsRUFBRSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUM7b0JBQ2pDLHNCQUFzQixFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLENBQUM7b0JBQ3hDLFFBQVEsRUFBRSxFQUFFO2lCQUNiO2FBQ0YsQ0FBQztZQUVGLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsV0FBa0IsQ0FBQyxDQUFDO1lBRTNFLE1BQU0sTUFBTSxHQUFHLE1BQU0sdUJBQXVCLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRXBFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDL0IsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDckMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2QyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNyQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzNDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3pDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsb0JBQW9CLEVBQUUsR0FBRyxFQUFFO1FBQ2xDLElBQUksQ0FBQyxpQ0FBaUMsRUFBRSxHQUFHLEVBQUU7WUFDM0MsTUFBTSxTQUFTLEdBQUc7Z0JBQ2hCLFFBQVEsRUFBRSxVQUFVO2dCQUNwQixLQUFLLEVBQUUsQ0FBQztnQkFDUixPQUFPLEVBQUUsYUFBYTthQUN2QixDQUFDO1lBRUYsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLHVCQUF1QixDQUFDLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3BGLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLDZCQUE2QixFQUFFLEdBQUcsRUFBRTtZQUN2QyxNQUFNLFdBQVcsR0FBRztnQkFDbEIsUUFBUSxFQUFFLFVBQVU7Z0JBQ3BCLEtBQUssRUFBRSxFQUFFLEVBQUUsZ0JBQWdCO2dCQUMzQixPQUFPLEVBQUUsYUFBYTthQUN2QixDQUFDO1lBRUYsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLHVCQUF1QixDQUFDLGtCQUFrQixDQUFDLFdBQVcsQ0FBQyxDQUFDO2lCQUNsRSxPQUFPLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztRQUMvQyxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxnQ0FBZ0MsRUFBRSxHQUFHLEVBQUU7WUFDMUMsTUFBTSxXQUFXLEdBQUc7Z0JBQ2xCLEtBQUssRUFBRSxDQUFDO2dCQUNSLE9BQU8sRUFBRSxhQUFhO2FBQ3ZCLENBQUM7WUFFRixNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsdUJBQXVCLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDLENBQUM7aUJBQ2xFLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1FBQ3JDLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLHFDQUFxQyxFQUFFLEdBQUcsRUFBRTtZQUMvQyxNQUFNLFdBQVcsR0FBRztnQkFDbEIsUUFBUSxFQUFFLFVBQVUsRUFBRSx3QkFBd0I7Z0JBQzlDLEtBQUssRUFBRSxDQUFDO2dCQUNSLE9BQU8sRUFBRSxhQUFhO2FBQ3ZCLENBQUM7WUFFRixNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsdUJBQXVCLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDLENBQUM7aUJBQ2xFLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1FBQ3RDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFO1FBQzlCLElBQUksQ0FBQyxzREFBc0QsRUFBRSxLQUFLLElBQUksRUFBRTtZQUN0RSxNQUFNLE1BQU0sR0FBRyxDQUFDLENBQUM7WUFDakIsTUFBTSxVQUFVLEdBQUc7Z0JBQ2pCLFFBQVEsRUFBRSxVQUFVO2dCQUNwQixLQUFLLEVBQUUsQ0FBQztnQkFDUixPQUFPLEVBQUUsYUFBYTthQUN2QixDQUFDO1lBRUYsVUFBVSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FDbEQsSUFBSSxLQUFLLENBQUMsNEJBQTRCLENBQUMsQ0FDeEMsQ0FBQztZQUVGLE1BQU0sTUFBTSxDQUNWLHVCQUF1QixDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsVUFBVSxDQUFDLENBQ3pELENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1FBQ2xELENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLG1EQUFtRCxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ25FLE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQztZQUMzQixNQUFNLE9BQU8sR0FBRyx5QkFBeUIsQ0FBQztZQUUxQyxNQUFNLFVBQVUsR0FBRztnQkFDakIsRUFBRSxFQUFFLFFBQVE7Z0JBQ1osS0FBSyxFQUFFLENBQUM7Z0JBQ1IsT0FBTyxFQUFFLGFBQWE7YUFDdkIsQ0FBQztZQUVGLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsaUJBQWlCLENBQUMsVUFBaUIsQ0FBQyxDQUFDO1lBQzVFLFVBQVUsQ0FBQyxZQUFZLENBQUMsaUJBQWlCLENBQUMsSUFBSSxLQUFLLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDO1lBRTNFLE1BQU0sTUFBTSxDQUNWLHVCQUF1QixDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FDNUQsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFDMUMsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsSUFBSSxDQUFDLGdEQUFnRCxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ3JFLE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQztZQUMzQixNQUFNLFlBQVksR0FBRyxtQkFBbUIsQ0FBQztZQUV6Qyw4REFBOEQ7WUFDOUQsTUFBTSx1QkFBdUIsQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUM7WUFFekUsTUFBTSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQztnQkFDOUQsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRTtnQkFDdkIsSUFBSSxFQUFFO29CQUNKLE1BQU0sRUFBRSxRQUFRO29CQUNoQixZQUFZO29CQUNaLFNBQVMsRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztpQkFDNUI7YUFDRixDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLDBCQUEwQixFQUFFLEdBQUcsRUFBRTtRQUN4QyxJQUFJLENBQUMscUNBQXFDLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDckQsTUFBTSxRQUFRLEdBQUcsU0FBUyxDQUFDO1lBQzNCLE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FDdEQsSUFBSSxDQUFDLHlCQUF5QixDQUFDLEVBQUUsQ0FDbEMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFYixNQUFNLFVBQVUsR0FBRztnQkFDakIsRUFBRSxFQUFFLFFBQVE7Z0JBQ1osS0FBSyxFQUFFLENBQUM7Z0JBQ1IsT0FBTyxFQUFFLGFBQWE7YUFDdkIsQ0FBQztZQUVGLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsaUJBQWlCLENBQUMsVUFBaUIsQ0FBQyxDQUFDO1lBQzVFLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsRUFBUyxDQUFDLENBQUM7WUFDaEUsVUFBVSxDQUFDLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFLEVBQUU7Z0JBQzVELE9BQU8sTUFBTSxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDcEMsQ0FBQyxDQUFDLENBQUM7WUFDSCxVQUFVLENBQUMscUJBQXFCLENBQUMsVUFBVSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBUyxDQUFDLENBQUM7WUFFdEYsTUFBTSxNQUFNLEdBQUcsTUFBTSx1QkFBdUIsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFFbkYsTUFBTSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDekMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFL0MsZ0RBQWdEO1lBQ2hELE1BQU0sQ0FBQyxVQUFVLENBQUMscUJBQXFCLENBQUMsVUFBVSxDQUFDLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUN6RSxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxtY2lzYWFjL0dpdEh1Yi90ZWFjaGluZy1lbmdpbmUyLjAvc2VydmVyL3Rlc3RzL3VuaXQvY3VycmljdWx1bUltcG9ydFNlcnZpY2UudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXNjcmliZSwgdGVzdCwgZXhwZWN0LCBiZWZvcmVFYWNoLCBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5pbXBvcnQgeyBDdXJyaWN1bHVtSW1wb3J0U2VydmljZSB9IGZyb20gJy4uLy4uL3NyYy9zZXJ2aWNlcy9jdXJyaWN1bHVtSW1wb3J0U2VydmljZSc7XG5pbXBvcnQgeyBwcmlzbWEgfSBmcm9tICcuLi8uLi9zcmMvcHJpc21hJztcblxuLy8gTW9jayBleHRlcm5hbCBzZXJ2aWNlc1xuamVzdC5tb2NrKCcuLi8uLi9zcmMvc2VydmljZXMvZW1iZWRkaW5nU2VydmljZScsICgpID0+ICh7XG4gIGVtYmVkZGluZ1NlcnZpY2U6IHtcbiAgICBnZW5lcmF0ZUVtYmVkZGluZzogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKFswLjEsIDAuMiwgMC4zXSksXG4gICAgZ2VuZXJhdGVCYXRjaEVtYmVkZGluZ3M6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShbWzAuMSwgMC4yLCAwLjNdLCBbMC40LCAwLjUsIDAuNl1dKSxcbiAgfSxcbn0pKTtcblxuamVzdC5tb2NrKCcuLi8uLi9zcmMvc2VydmljZXMvY2x1c3RlcmluZ1NlcnZpY2UnLCAoKSA9PiAoe1xuICBjbHVzdGVyaW5nU2VydmljZToge1xuICAgIGNsdXN0ZXJFeHBlY3RhdGlvbnM6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShbXG4gICAgICB7XG4gICAgICAgIGNsdXN0ZXJOYW1lOiAnTnVtYmVyIE9wZXJhdGlvbnMnLFxuICAgICAgICBjbHVzdGVyVHlwZTogJ2NvbmNlcHQnLFxuICAgICAgICBleHBlY3RhdGlvbklkczogWydleHAxJywgJ2V4cDInXSxcbiAgICAgICAgY29uZmlkZW5jZTogMC44NSxcbiAgICAgIH0sXG4gICAgXSksXG4gIH0sXG59KSk7XG5cbmNvbnN0IG1vY2tQcmlzbWEgPSBwcmlzbWE7XG5cbmRlc2NyaWJlKCdDdXJyaWN1bHVtSW1wb3J0U2VydmljZScsICgpID0+IHtcbiAgbGV0IGN1cnJpY3VsdW1JbXBvcnRTZXJ2aWNlOiBDdXJyaWN1bHVtSW1wb3J0U2VydmljZTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBjdXJyaWN1bHVtSW1wb3J0U2VydmljZSA9IG5ldyBDdXJyaWN1bHVtSW1wb3J0U2VydmljZSgpO1xuICB9KTtcblxuICBkZXNjcmliZS5za2lwKCdjcmVhdGVJbXBvcnQnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGNyZWF0ZSBuZXcgY3VycmljdWx1bSBpbXBvcnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB1c2VySWQgPSAxO1xuICAgICAgY29uc3QgaW1wb3J0RGF0YSA9IHtcbiAgICAgICAgZmlsZW5hbWU6ICd0ZXN0LWN1cnJpY3VsdW0ucGRmJyxcbiAgICAgICAgb3JpZ2luYWxOYW1lOiAnR3JhZGUgMSBNYXRoIEN1cnJpY3VsdW0ucGRmJyxcbiAgICAgICAgZ3JhZGU6IDEsXG4gICAgICAgIHN1YmplY3Q6ICdNYXRoZW1hdGljcycsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrSW1wb3J0ID0ge1xuICAgICAgICBpZDogJ2ltcG9ydDEnLFxuICAgICAgICB1c2VySWQsXG4gICAgICAgIC4uLmltcG9ydERhdGEsXG4gICAgICAgIHN0YXR1czogJ1VQTE9BRElORycsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC5jcmVhdGUubW9ja1Jlc29sdmVkVmFsdWUobW9ja0ltcG9ydCBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjdXJyaWN1bHVtSW1wb3J0U2VydmljZS5jcmVhdGVJbXBvcnQodXNlcklkLCBpbXBvcnREYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrSW1wb3J0KTtcbiAgICAgIGV4cGVjdChtb2NrUHJpc21hLmN1cnJpY3VsdW1JbXBvcnQuY3JlYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgLi4uaW1wb3J0RGF0YSxcbiAgICAgICAgICBzdGF0dXM6ICdVUExPQURJTkcnLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlLnNraXAoJ3VwZGF0ZUltcG9ydFN0YXR1cycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgdXBkYXRlIGltcG9ydCBzdGF0dXMgYW5kIG1ldGFkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW1wb3J0SWQgPSAnaW1wb3J0MSc7XG4gICAgICBjb25zdCBzdGF0dXMgPSAnUFJPQ0VTU0lORyc7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHsgc3RlcDogJ3BhcnNpbmdfcGRmJyB9O1xuXG4gICAgICBjb25zdCBtb2NrVXBkYXRlZEltcG9ydCA9IHtcbiAgICAgICAgaWQ6IGltcG9ydElkLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICB9O1xuXG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1JbXBvcnQudXBkYXRlLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVcGRhdGVkSW1wb3J0IGFzIGFueSk7XG5cbiAgICAgIC8vIEB0cy1pZ25vcmUgLSBtZXRob2QgZG9lc24ndCBleGlzdCBpbiBjdXJyZW50IGltcGxlbWVudGF0aW9uXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjdXJyaWN1bHVtSW1wb3J0U2VydmljZS51cGRhdGVJbXBvcnRTdGF0dXMoaW1wb3J0SWQsIHN0YXR1cywgbWV0YWRhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tVcGRhdGVkSW1wb3J0KTtcbiAgICAgIGV4cGVjdChtb2NrUHJpc21hLmN1cnJpY3VsdW1JbXBvcnQudXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIHdoZXJlOiB7IGlkOiBpbXBvcnRJZCB9LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgIHVwZGF0ZWRBdDogZXhwZWN0LmFueShEYXRlKSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBwcm9jZXNzaW5nIGNvbXBsZXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbXBvcnRJZCA9ICdpbXBvcnQxJztcbiAgICAgIGNvbnN0IHN0YXR1cyA9ICdDT01QTEVURUQnO1xuXG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1JbXBvcnQudXBkYXRlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgaWQ6IGltcG9ydElkLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIHByb2Nlc3NlZEF0OiBleHBlY3QuYW55KERhdGUpLFxuICAgICAgICBjb21wbGV0ZWRBdDogZXhwZWN0LmFueShEYXRlKSxcbiAgICAgIH0gYXMgYW55KTtcblxuICAgICAgYXdhaXQgY3VycmljdWx1bUltcG9ydFNlcnZpY2UudXBkYXRlSW1wb3J0U3RhdHVzKGltcG9ydElkLCBzdGF0dXMpO1xuXG4gICAgICBleHBlY3QobW9ja1ByaXNtYS5jdXJyaWN1bHVtSW1wb3J0LnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB3aGVyZTogeyBpZDogaW1wb3J0SWQgfSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICBwcm9jZXNzZWRBdDogZXhwZWN0LmFueShEYXRlKSxcbiAgICAgICAgICBjb21wbGV0ZWRBdDogZXhwZWN0LmFueShEYXRlKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IGV4cGVjdC5hbnkoRGF0ZSksXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUuc2tpcCgncGFyc2VUZXh0Q29udGVudCcsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgcGFyc2UgY3VycmljdWx1bSB0ZXh0IGludG8gc3RydWN0dXJlZCBleHBlY3RhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbXBvcnRJZCA9ICdpbXBvcnQxJztcbiAgICAgIGNvbnN0IHJhd1RleHQgPSBgXG4gICAgICAgIEExLjEgLSBTdHVkZW50cyB3aWxsIGRlbW9uc3RyYXRlIHVuZGVyc3RhbmRpbmcgb2YgbnVtYmVycyAxLTEwXG4gICAgICAgIEExLjIgLSBTdHVkZW50cyB3aWxsIGNvdW50IG9iamVjdHMgYWNjdXJhdGVseSB1cCB0byAyMFxuICAgICAgICBCMi4xIC0gU3R1ZGVudHMgd2lsbCBpZGVudGlmeSBhbmQgZXh0ZW5kIHNpbXBsZSBwYXR0ZXJuc1xuICAgICAgYDtcblxuICAgICAgY29uc3QgbW9ja0ltcG9ydCA9IHtcbiAgICAgICAgaWQ6IGltcG9ydElkLFxuICAgICAgICBncmFkZTogMSxcbiAgICAgICAgc3ViamVjdDogJ01hdGhlbWF0aWNzJyxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC5maW5kVW5pcXVlLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tJbXBvcnQgYXMgYW55KTtcbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC51cGRhdGUubW9ja1Jlc29sdmVkVmFsdWUoe30gYXMgYW55KTtcbiAgICAgIG1vY2tQcmlzbWEuJHRyYW5zYWN0aW9uLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNhbGxiYWNrKG1vY2tQcmlzbWEpO1xuICAgICAgfSk7XG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1FeHBlY3RhdGlvbi5jcmVhdGVNYW55Lm1vY2tSZXNvbHZlZFZhbHVlKHsgY291bnQ6IDMgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjdXJyaWN1bHVtSW1wb3J0U2VydmljZS5wYXJzZVRleHRDb250ZW50KGltcG9ydElkLCByYXdUZXh0KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5wcm9jZXNzZWRDb3VudCkudG9CZSgzKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXhwZWN0YXRpb25zKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICBleHBlY3QocmVzdWx0LmV4cGVjdGF0aW9uc1swXS5jb2RlKS50b0JlKCdBMS4xJyk7XG4gICAgICBleHBlY3QocmVzdWx0LmV4cGVjdGF0aW9uc1swXS5kZXNjcmlwdGlvbikudG9CZSgnU3R1ZGVudHMgd2lsbCBkZW1vbnN0cmF0ZSB1bmRlcnN0YW5kaW5nIG9mIG51bWJlcnMgMS0xMCcpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5leHBlY3RhdGlvbnNbMV0uY29kZSkudG9CZSgnQTEuMicpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5leHBlY3RhdGlvbnNbMl0uY29kZSkudG9CZSgnQjIuMScpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBtYWxmb3JtZWQgdGV4dCBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW1wb3J0SWQgPSAnaW1wb3J0MSc7XG4gICAgICBjb25zdCByYXdUZXh0ID0gYFxuICAgICAgICBJbnZhbGlkIGxpbmUgd2l0aG91dCBwcm9wZXIgZm9ybWF0XG4gICAgICAgIEExLjEgLSBWYWxpZCBleHBlY3RhdGlvblxuICAgICAgICBBbm90aGVyIGludmFsaWQgbGluZVxuICAgICAgYDtcblxuICAgICAgY29uc3QgbW9ja0ltcG9ydCA9IHtcbiAgICAgICAgaWQ6IGltcG9ydElkLFxuICAgICAgICBncmFkZTogMSxcbiAgICAgICAgc3ViamVjdDogJ01hdGhlbWF0aWNzJyxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC5maW5kVW5pcXVlLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tJbXBvcnQgYXMgYW55KTtcbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC51cGRhdGUubW9ja1Jlc29sdmVkVmFsdWUoe30gYXMgYW55KTtcbiAgICAgIG1vY2tQcmlzbWEuJHRyYW5zYWN0aW9uLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNhbGxiYWNrKG1vY2tQcmlzbWEpO1xuICAgICAgfSk7XG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1FeHBlY3RhdGlvbi5jcmVhdGVNYW55Lm1vY2tSZXNvbHZlZFZhbHVlKHsgY291bnQ6IDEgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjdXJyaWN1bHVtSW1wb3J0U2VydmljZS5wYXJzZVRleHRDb250ZW50KGltcG9ydElkLCByYXdUZXh0KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5wcm9jZXNzZWRDb3VudCkudG9CZSgxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXhwZWN0YXRpb25zKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QocmVzdWx0LmV4cGVjdGF0aW9uc1swXS5jb2RlKS50b0JlKCdBMS4xJyk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9ycykudG9IYXZlTGVuZ3RoKDIpOyAvLyBUd28gaW52YWxpZCBsaW5lc1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgncHJvY2Vzc0NTVkNvbnRlbnQnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHBhcnNlIENTViBjdXJyaWN1bHVtIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbXBvcnRJZCA9ICdpbXBvcnQxJztcbiAgICAgIGNvbnN0IGNzdkNvbnRlbnQgPSBgY29kZSxkZXNjcmlwdGlvbixzdHJhbmQsc3Vic3RyYW5kLGdyYWRlLHN1YmplY3RcbkExLjEsXCJTdHVkZW50cyB3aWxsIGRlbW9uc3RyYXRlIHVuZGVyc3RhbmRpbmcgb2YgbnVtYmVycyAxLTEwXCIsXCJOdW1iZXIgU2Vuc2VcIixcIkNvdW50aW5nXCIsMSxcIk1hdGhlbWF0aWNzXCJcbkExLjIsXCJTdHVkZW50cyB3aWxsIGNvdW50IG9iamVjdHMgYWNjdXJhdGVseSB1cCB0byAyMFwiLFwiTnVtYmVyIFNlbnNlXCIsXCJDb3VudGluZ1wiLDEsXCJNYXRoZW1hdGljc1wiXG5CMi4xLFwiU3R1ZGVudHMgd2lsbCBpZGVudGlmeSBhbmQgZXh0ZW5kIHNpbXBsZSBwYXR0ZXJuc1wiLFwiUGF0dGVybnNcIixcIlNpbXBsZSBQYXR0ZXJuc1wiLDEsXCJNYXRoZW1hdGljc1wiYDtcblxuICAgICAgY29uc3QgbW9ja0ltcG9ydCA9IHtcbiAgICAgICAgaWQ6IGltcG9ydElkLFxuICAgICAgICBncmFkZTogMSxcbiAgICAgICAgc3ViamVjdDogJ01hdGhlbWF0aWNzJyxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC5maW5kVW5pcXVlLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tJbXBvcnQgYXMgYW55KTtcbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC51cGRhdGUubW9ja1Jlc29sdmVkVmFsdWUoe30gYXMgYW55KTtcbiAgICAgIG1vY2tQcmlzbWEuJHRyYW5zYWN0aW9uLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNhbGxiYWNrKG1vY2tQcmlzbWEpO1xuICAgICAgfSk7XG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1FeHBlY3RhdGlvbi5jcmVhdGVNYW55Lm1vY2tSZXNvbHZlZFZhbHVlKHsgY291bnQ6IDMgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjdXJyaWN1bHVtSW1wb3J0U2VydmljZS5wcm9jZXNzQ1NWQ29udGVudChpbXBvcnRJZCwgY3N2Q29udGVudCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQucHJvY2Vzc2VkQ291bnQpLnRvQmUoMyk7XG4gICAgICBleHBlY3QocmVzdWx0LmV4cGVjdGF0aW9ucykudG9IYXZlTGVuZ3RoKDMpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5leHBlY3RhdGlvbnNbMF0uc3RyYW5kKS50b0JlKCdOdW1iZXIgU2Vuc2UnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXhwZWN0YXRpb25zWzBdLnN1YnN0cmFuZCkudG9CZSgnQ291bnRpbmcnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXhwZWN0YXRpb25zWzJdLnN0cmFuZCkudG9CZSgnUGF0dGVybnMnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbWlzc2luZyByZXF1aXJlZCBjb2x1bW5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW1wb3J0SWQgPSAnaW1wb3J0MSc7XG4gICAgICBjb25zdCBjc3ZDb250ZW50ID0gYGRlc2NyaXB0aW9uLHN0cmFuZFxuXCJTdHVkZW50cyB3aWxsIGRlbW9uc3RyYXRlIHVuZGVyc3RhbmRpbmcgb2YgbnVtYmVycyAxLTEwXCIsXCJOdW1iZXIgU2Vuc2VcImA7XG5cbiAgICAgIGNvbnN0IG1vY2tJbXBvcnQgPSB7XG4gICAgICAgIGlkOiBpbXBvcnRJZCxcbiAgICAgICAgZ3JhZGU6IDEsXG4gICAgICAgIHN1YmplY3Q6ICdNYXRoZW1hdGljcycsXG4gICAgICB9O1xuXG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1JbXBvcnQuZmluZFVuaXF1ZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrSW1wb3J0IGFzIGFueSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgY3VycmljdWx1bUltcG9ydFNlcnZpY2UucHJvY2Vzc0NTVkNvbnRlbnQoaW1wb3J0SWQsIGNzdkNvbnRlbnQpXG4gICAgICApLnJlamVjdHMudG9UaHJvdygnTWlzc2luZyByZXF1aXJlZCBjb2x1bW5zJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZW5lcmF0ZUNsdXN0ZXJzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBjcmVhdGUgZXhwZWN0YXRpb24gY2x1c3RlcnMgdXNpbmcgQUknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbXBvcnRJZCA9ICdpbXBvcnQxJztcblxuICAgICAgY29uc3QgbW9ja0V4cGVjdGF0aW9ucyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAnZXhwMScsXG4gICAgICAgICAgY29kZTogJ0ExLjEnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTnVtYmVyIHJlY29nbml0aW9uJyxcbiAgICAgICAgICBzdHJhbmQ6ICdOdW1iZXIgU2Vuc2UnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdleHAyJyxcbiAgICAgICAgICBjb2RlOiAnQTEuMicsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdDb3VudGluZyBvYmplY3RzJyxcbiAgICAgICAgICBzdHJhbmQ6ICdOdW1iZXIgU2Vuc2UnLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgbW9ja1ByaXNtYS5jdXJyaWN1bHVtRXhwZWN0YXRpb24uZmluZE1hbnkubW9ja1Jlc29sdmVkVmFsdWUobW9ja0V4cGVjdGF0aW9ucyBhcyBhbnkpO1xuICAgICAgbW9ja1ByaXNtYS5leHBlY3RhdGlvbkNsdXN0ZXIuY3JlYXRlTWFueS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGNvdW50OiAxIH0gYXMgYW55KTtcbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC51cGRhdGUubW9ja1Jlc29sdmVkVmFsdWUoe30gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3VycmljdWx1bUltcG9ydFNlcnZpY2UuZ2VuZXJhdGVDbHVzdGVycyhpbXBvcnRJZCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY2x1c3RlcnNDcmVhdGVkKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jbHVzdGVycykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jbHVzdGVyc1swXS5jbHVzdGVyTmFtZSkudG9CZSgnTnVtYmVyIE9wZXJhdGlvbnMnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY2x1c3RlcnNbMF0uZXhwZWN0YXRpb25JZHMpLnRvRXF1YWwoWydleHAxJywgJ2V4cDInXSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGVtcHR5IGV4cGVjdGF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGltcG9ydElkID0gJ2ltcG9ydDEnO1xuXG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1FeHBlY3RhdGlvbi5maW5kTWFueS5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGN1cnJpY3VsdW1JbXBvcnRTZXJ2aWNlLmdlbmVyYXRlQ2x1c3RlcnMoaW1wb3J0SWQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmNsdXN0ZXJzQ3JlYXRlZCkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY2x1c3RlcnMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldEltcG9ydFByb2dyZXNzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gZGV0YWlsZWQgaW1wb3J0IHByb2dyZXNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW1wb3J0SWQgPSAnaW1wb3J0MSc7XG5cbiAgICAgIGNvbnN0IG1vY2tJbXBvcnQgPSB7XG4gICAgICAgIGlkOiBpbXBvcnRJZCxcbiAgICAgICAgc3RhdHVzOiAnUFJPQ0VTU0lORycsXG4gICAgICAgIHRvdGFsT3V0Y29tZXM6IDEwMCxcbiAgICAgICAgcHJvY2Vzc2VkT3V0Y29tZXM6IDc1LFxuICAgICAgICBlcnJvckxvZzogW1xuICAgICAgICAgIHsgbGluZTogMTAsIGVycm9yOiAnSW52YWxpZCBmb3JtYXQnIH0sXG4gICAgICAgICAgeyBsaW5lOiAyNSwgZXJyb3I6ICdNaXNzaW5nIGNvZGUnIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoJzIwMjQtMDEtMDEnKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgnMjAyNC0wMS0wMicpLFxuICAgICAgfTtcblxuICAgICAgbW9ja1ByaXNtYS5jdXJyaWN1bHVtSW1wb3J0LmZpbmRVbmlxdWUubW9ja1Jlc29sdmVkVmFsdWUobW9ja0ltcG9ydCBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjdXJyaWN1bHVtSW1wb3J0U2VydmljZS5nZXRJbXBvcnRQcm9ncmVzcyhpbXBvcnRJZCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICBpZDogaW1wb3J0SWQsXG4gICAgICAgIHN0YXR1czogJ1BST0NFU1NJTkcnLFxuICAgICAgICBwcm9ncmVzczogNzUsIC8vIHByb2Nlc3NlZE91dGNvbWVzIC8gdG90YWxPdXRjb21lcyAqIDEwMFxuICAgICAgICB0b3RhbE91dGNvbWVzOiAxMDAsXG4gICAgICAgIHByb2Nlc3NlZE91dGNvbWVzOiA3NSxcbiAgICAgICAgZXJyb3JDb3VudDogMixcbiAgICAgICAgZXJyb3JzOiBtb2NrSW1wb3J0LmVycm9yTG9nLFxuICAgICAgICBjcmVhdGVkQXQ6IG1vY2tJbXBvcnQuY3JlYXRlZEF0LFxuICAgICAgICB1cGRhdGVkQXQ6IG1vY2tJbXBvcnQudXBkYXRlZEF0LFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGltcG9ydCBub3QgZm91bmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbXBvcnRJZCA9ICdub25leGlzdGVudCc7XG5cbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC5maW5kVW5pcXVlLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIGN1cnJpY3VsdW1JbXBvcnRTZXJ2aWNlLmdldEltcG9ydFByb2dyZXNzKGltcG9ydElkKVxuICAgICAgKS5yZWplY3RzLnRvVGhyb3coJ0ltcG9ydCBub3QgZm91bmQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldFVzZXJJbXBvcnRzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdXNlciBpbXBvcnRzIHdpdGggc3RhdGlzdGljcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IDE7XG5cbiAgICAgIGNvbnN0IG1vY2tJbXBvcnRzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdpbXBvcnQxJyxcbiAgICAgICAgICBmaWxlbmFtZTogJ2dyYWRlMS1tYXRoLnBkZicsXG4gICAgICAgICAgc3RhdHVzOiAnQ09NUExFVEVEJyxcbiAgICAgICAgICBncmFkZTogMSxcbiAgICAgICAgICBzdWJqZWN0OiAnTWF0aGVtYXRpY3MnLFxuICAgICAgICAgIHRvdGFsT3V0Y29tZXM6IDUwLFxuICAgICAgICAgIHByb2Nlc3NlZE91dGNvbWVzOiA1MCxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCcyMDI0LTAxLTAxJyksXG4gICAgICAgICAgY3VycmljdWx1bUV4cGVjdGF0aW9uczogW3sgaWQ6ICdleHAxJyB9LCB7IGlkOiAnZXhwMicgfV0sXG4gICAgICAgICAgY2x1c3RlcnM6IFt7IGlkOiAnY2x1c3RlcjEnIH1dLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdpbXBvcnQyJyxcbiAgICAgICAgICBmaWxlbmFtZTogJ2dyYWRlMS1zY2llbmNlLnBkZicsXG4gICAgICAgICAgc3RhdHVzOiAnUFJPQ0VTU0lORycsXG4gICAgICAgICAgZ3JhZGU6IDEsXG4gICAgICAgICAgc3ViamVjdDogJ1NjaWVuY2UnLFxuICAgICAgICAgIHRvdGFsT3V0Y29tZXM6IDMwLFxuICAgICAgICAgIHByb2Nlc3NlZE91dGNvbWVzOiAyMCxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCcyMDI0LTAxLTAyJyksXG4gICAgICAgICAgY3VycmljdWx1bUV4cGVjdGF0aW9uczogW3sgaWQ6ICdleHAzJyB9XSxcbiAgICAgICAgICBjbHVzdGVyczogW10sXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1JbXBvcnQuZmluZE1hbnkubW9ja1Jlc29sdmVkVmFsdWUobW9ja0ltcG9ydHMgYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3VycmljdWx1bUltcG9ydFNlcnZpY2UuZ2V0VXNlckltcG9ydHModXNlcklkKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdFswXS5pZCkudG9CZSgnaW1wb3J0MScpO1xuICAgICAgZXhwZWN0KHJlc3VsdFswXS5leHBlY3RhdGlvbkNvdW50KS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdFswXS5jbHVzdGVyQ291bnQpLnRvQmUoMSk7XG4gICAgICBleHBlY3QocmVzdWx0WzFdLmlkKS50b0JlKCdpbXBvcnQyJyk7XG4gICAgICBleHBlY3QocmVzdWx0WzFdLmV4cGVjdGF0aW9uQ291bnQpLnRvQmUoMSk7XG4gICAgICBleHBlY3QocmVzdWx0WzFdLmNsdXN0ZXJDb3VudCkudG9CZSgwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3ZhbGlkYXRlSW1wb3J0RGF0YScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgdmFsaWRhdGUgcmVxdWlyZWQgZmllbGRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWREYXRhID0ge1xuICAgICAgICBmaWxlbmFtZTogJ3Rlc3QucGRmJyxcbiAgICAgICAgZ3JhZGU6IDEsXG4gICAgICAgIHN1YmplY3Q6ICdNYXRoZW1hdGljcycsXG4gICAgICB9O1xuXG4gICAgICBleHBlY3QoKCkgPT4gY3VycmljdWx1bUltcG9ydFNlcnZpY2UudmFsaWRhdGVJbXBvcnREYXRhKHZhbGlkRGF0YSkpLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgZ3JhZGUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkRGF0YSA9IHtcbiAgICAgICAgZmlsZW5hbWU6ICd0ZXN0LnBkZicsXG4gICAgICAgIGdyYWRlOiAxNSwgLy8gSW52YWxpZCBncmFkZVxuICAgICAgICBzdWJqZWN0OiAnTWF0aGVtYXRpY3MnLFxuICAgICAgfTtcblxuICAgICAgZXhwZWN0KCgpID0+IGN1cnJpY3VsdW1JbXBvcnRTZXJ2aWNlLnZhbGlkYXRlSW1wb3J0RGF0YShpbnZhbGlkRGF0YSkpXG4gICAgICAgIC50b1Rocm93KCdHcmFkZSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgMTInKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZWplY3QgbWlzc2luZyBmaWxlbmFtZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWREYXRhID0ge1xuICAgICAgICBncmFkZTogMSxcbiAgICAgICAgc3ViamVjdDogJ01hdGhlbWF0aWNzJyxcbiAgICAgIH07XG5cbiAgICAgIGV4cGVjdCgoKSA9PiBjdXJyaWN1bHVtSW1wb3J0U2VydmljZS52YWxpZGF0ZUltcG9ydERhdGEoaW52YWxpZERhdGEpKVxuICAgICAgICAudG9UaHJvdygnRmlsZW5hbWUgaXMgcmVxdWlyZWQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZWplY3QgdW5zdXBwb3J0ZWQgZmlsZSB0eXBlJywgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZERhdGEgPSB7XG4gICAgICAgIGZpbGVuYW1lOiAndGVzdC50eHQnLCAvLyBVbnN1cHBvcnRlZCBleHRlbnNpb25cbiAgICAgICAgZ3JhZGU6IDEsXG4gICAgICAgIHN1YmplY3Q6ICdNYXRoZW1hdGljcycsXG4gICAgICB9O1xuXG4gICAgICBleHBlY3QoKCkgPT4gY3VycmljdWx1bUltcG9ydFNlcnZpY2UudmFsaWRhdGVJbXBvcnREYXRhKGludmFsaWREYXRhKSlcbiAgICAgICAgLnRvVGhyb3coJ1Vuc3VwcG9ydGVkIGZpbGUgdHlwZScpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZXJyb3IgaGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBlcnJvcnMgZHVyaW5nIGltcG9ydCBjcmVhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IDE7XG4gICAgICBjb25zdCBpbXBvcnREYXRhID0ge1xuICAgICAgICBmaWxlbmFtZTogJ3Rlc3QucGRmJyxcbiAgICAgICAgZ3JhZGU6IDEsXG4gICAgICAgIHN1YmplY3Q6ICdNYXRoZW1hdGljcycsXG4gICAgICB9O1xuXG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1JbXBvcnQuY3JlYXRlLm1vY2tSZWplY3RlZFZhbHVlKFxuICAgICAgICBuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJylcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgY3VycmljdWx1bUltcG9ydFNlcnZpY2UuY3JlYXRlSW1wb3J0KHVzZXJJZCwgaW1wb3J0RGF0YSlcbiAgICAgICkucmVqZWN0cy50b1Rocm93KCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSB0cmFuc2FjdGlvbiBmYWlsdXJlcyBkdXJpbmcgcGFyc2luZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGltcG9ydElkID0gJ2ltcG9ydDEnO1xuICAgICAgY29uc3QgcmF3VGV4dCA9ICdBMS4xIC0gVGVzdCBleHBlY3RhdGlvbic7XG5cbiAgICAgIGNvbnN0IG1vY2tJbXBvcnQgPSB7XG4gICAgICAgIGlkOiBpbXBvcnRJZCxcbiAgICAgICAgZ3JhZGU6IDEsXG4gICAgICAgIHN1YmplY3Q6ICdNYXRoZW1hdGljcycsXG4gICAgICB9O1xuXG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1JbXBvcnQuZmluZFVuaXF1ZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrSW1wb3J0IGFzIGFueSk7XG4gICAgICBtb2NrUHJpc21hLiR0cmFuc2FjdGlvbi5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGZhaWxlZCcpKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBjdXJyaWN1bHVtSW1wb3J0U2VydmljZS5wYXJzZVRleHRDb250ZW50KGltcG9ydElkLCByYXdUZXh0KVxuICAgICAgKS5yZWplY3RzLnRvVGhyb3coJ1RyYW5zYWN0aW9uIGZhaWxlZCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdC5za2lwKCdzaG91bGQgdXBkYXRlIGltcG9ydCBzdGF0dXMgdG8gRkFJTEVEIG9uIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW1wb3J0SWQgPSAnaW1wb3J0MSc7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAnUHJvY2Vzc2luZyBmYWlsZWQnO1xuXG4gICAgICAvLyBAdHMtaWdub3JlIC0gbWV0aG9kIGRvZXNuJ3QgZXhpc3QgaW4gY3VycmVudCBpbXBsZW1lbnRhdGlvblxuICAgICAgYXdhaXQgY3VycmljdWx1bUltcG9ydFNlcnZpY2UubWFya0ltcG9ydEFzRmFpbGVkKGltcG9ydElkLCBlcnJvck1lc3NhZ2UpO1xuXG4gICAgICBleHBlY3QobW9ja1ByaXNtYS5jdXJyaWN1bHVtSW1wb3J0LnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB3aGVyZTogeyBpZDogaW1wb3J0SWQgfSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHN0YXR1czogJ0ZBSUxFRCcsXG4gICAgICAgICAgZXJyb3JNZXNzYWdlLFxuICAgICAgICAgIHVwZGF0ZWRBdDogZXhwZWN0LmFueShEYXRlKSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgncGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBiYXRjaCBwcm9jZXNzIGxhcmdlIGRhdGFzZXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW1wb3J0SWQgPSAnaW1wb3J0MSc7XG4gICAgICBjb25zdCBsYXJnZVRleHQgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAwIH0sIChfLCBpKSA9PiBcbiAgICAgICAgYEEke2l9LjEgLSBUZXN0IGV4cGVjdGF0aW9uICR7aX1gXG4gICAgICApLmpvaW4oJ1xcbicpO1xuXG4gICAgICBjb25zdCBtb2NrSW1wb3J0ID0ge1xuICAgICAgICBpZDogaW1wb3J0SWQsXG4gICAgICAgIGdyYWRlOiAxLFxuICAgICAgICBzdWJqZWN0OiAnTWF0aGVtYXRpY3MnLFxuICAgICAgfTtcblxuICAgICAgbW9ja1ByaXNtYS5jdXJyaWN1bHVtSW1wb3J0LmZpbmRVbmlxdWUubW9ja1Jlc29sdmVkVmFsdWUobW9ja0ltcG9ydCBhcyBhbnkpO1xuICAgICAgbW9ja1ByaXNtYS5jdXJyaWN1bHVtSW1wb3J0LnVwZGF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7fSBhcyBhbnkpO1xuICAgICAgbW9ja1ByaXNtYS4kdHJhbnNhY3Rpb24ubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jIChjYWxsYmFjaykgPT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgY2FsbGJhY2sobW9ja1ByaXNtYSk7XG4gICAgICB9KTtcbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUV4cGVjdGF0aW9uLmNyZWF0ZU1hbnkubW9ja1Jlc29sdmVkVmFsdWUoeyBjb3VudDogMTAwMCB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGN1cnJpY3VsdW1JbXBvcnRTZXJ2aWNlLnBhcnNlVGV4dENvbnRlbnQoaW1wb3J0SWQsIGxhcmdlVGV4dCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQucHJvY2Vzc2VkQ291bnQpLnRvQmUoMTAwMCk7XG4gICAgICBleHBlY3QocmVzdWx0LmV4cGVjdGF0aW9ucykudG9IYXZlTGVuZ3RoKDEwMDApO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGF2ZSBjYWxsZWQgY3JlYXRlTWFueSB0byBiYXRjaCBpbnNlcnRcbiAgICAgIGV4cGVjdChtb2NrUHJpc21hLmN1cnJpY3VsdW1FeHBlY3RhdGlvbi5jcmVhdGVNYW55KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sInZlcnNpb24iOjN9