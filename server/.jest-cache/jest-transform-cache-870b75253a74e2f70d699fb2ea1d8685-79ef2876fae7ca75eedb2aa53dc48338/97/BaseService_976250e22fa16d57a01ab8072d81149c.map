{"file":"/Users/michaelmcisaac/GitHub/teaching-engine2.0/server/src/services/base/BaseService.ts","mappings":"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","names":[],"sources":["/Users/michaelmcisaac/GitHub/teaching-engine2.0/server/src/services/base/BaseService.ts"],"sourcesContent":["import { PrismaClient, Prisma } from '@teaching-engine/database';\nimport { prisma } from '../../prisma';\nimport logger from '../../logger';\nimport type { Logger } from 'pino';\n\nexport interface ServiceMetrics {\n  operationCount: number;\n  errorCount: number;\n  averageResponseTime: number;\n  lastOperation: Date;\n}\n\nexport interface RetryOptions {\n  maxRetries: number;\n  baseDelay: number;\n  maxDelay: number;\n  exponentialBackoff: boolean;\n}\n\nexport abstract class BaseService {\n  protected readonly prisma: PrismaClient;\n  protected readonly logger: Logger;\n  protected readonly serviceName: string;\n  private metrics: ServiceMetrics;\n\n  constructor(serviceName?: string) {\n    this.prisma = prisma;\n    this.serviceName = serviceName || this.constructor.name;\n    this.logger = logger.child({ service: this.serviceName });\n    this.metrics = {\n      operationCount: 0,\n      errorCount: 0,\n      averageResponseTime: 0,\n      lastOperation: new Date(),\n    };\n  }\n\n  /**\n   * Execute a function with retry logic and metrics tracking\n   */\n  protected async withRetry<T>(\n    operation: () => Promise<T>,\n    options: Partial<RetryOptions> = {},\n  ): Promise<T> {\n    const opts: RetryOptions = {\n      maxRetries: 3,\n      baseDelay: 1000,\n      maxDelay: 10000,\n      exponentialBackoff: true,\n      ...options,\n    };\n\n    const startTime = Date.now();\n    let lastError: unknown;\n\n    for (let attempt = 1; attempt <= opts.maxRetries + 1; attempt++) {\n      try {\n        const result = await operation();\n\n        // Update metrics on success\n        this.updateMetrics(Date.now() - startTime, false);\n\n        if (attempt > 1) {\n          this.logger.info(\n            { attempt, serviceName: this.serviceName },\n            'Operation succeeded after retry',\n          );\n        }\n\n        return result;\n      } catch (error) {\n        lastError = error;\n\n        if (attempt <= opts.maxRetries) {\n          const delay = opts.exponentialBackoff\n            ? Math.min(opts.baseDelay * Math.pow(2, attempt - 1), opts.maxDelay)\n            : opts.baseDelay;\n\n          this.logger.warn(\n            {\n              error: error.message,\n              attempt,\n              maxRetries: opts.maxRetries,\n              nextRetryIn: delay,\n              serviceName: this.serviceName,\n            },\n            'Operation failed, retrying',\n          );\n\n          await this.sleep(delay);\n        }\n      }\n    }\n\n    // Update metrics on final failure\n    this.updateMetrics(Date.now() - startTime, true);\n\n    this.logger.error(\n      {\n        error: lastError,\n        attempts: opts.maxRetries + 1,\n        serviceName: this.serviceName,\n      },\n      'All retry attempts failed',\n    );\n\n    throw lastError;\n  }\n\n  /**\n   * Execute a function within a database transaction\n   */\n  protected async withTransaction<T>(\n    operation: (tx: Prisma.TransactionClient) => Promise<T>,\n  ): Promise<T> {\n    return await this.withRetry(async () => {\n      return await this.prisma.$transaction(operation);\n    });\n  }\n\n  /**\n   * Execute multiple operations in parallel with error handling\n   */\n  protected async withParallel<T>(\n    operations: (() => Promise<T>)[],\n    options: {\n      failFast?: boolean;\n      maxConcurrency?: number;\n    } = {},\n  ): Promise<{\n    results: (T | null)[];\n    errors: (Error | null)[];\n    successCount: number;\n  }> {\n    const { failFast = false, maxConcurrency = 10 } = options;\n    const results: (T | null)[] = [];\n    const errors: (Error | null)[] = [];\n    let successCount = 0;\n\n    // Process operations in batches if max concurrency is set\n    const batches = this.createBatches(operations, maxConcurrency);\n    let globalIndex = 0;\n\n    for (const batch of batches) {\n      const batchStartIndex = globalIndex;\n      const promises = batch.map(async (operation, batchIndex) => {\n        const operationIndex = batchStartIndex + batchIndex;\n        try {\n          const result = await operation();\n          results[operationIndex] = result;\n          errors[operationIndex] = null;\n          successCount++;\n          return result;\n        } catch (error) {\n          results[operationIndex] = null;\n          errors[operationIndex] = error as Error;\n\n          if (failFast) {\n            throw error;\n          }\n\n          this.logger.warn(\n            {\n              error: (error as Error).message,\n              operationIndex: operationIndex,\n              serviceName: this.serviceName,\n            },\n            'Parallel operation failed',\n          );\n\n          return null;\n        }\n      });\n\n      if (failFast) {\n        try {\n          await Promise.all(promises);\n        } catch (error) {\n          // When failFast is true, stop processing remaining batches\n          break;\n        }\n      } else {\n        await Promise.all(promises);\n      }\n      globalIndex += batch.length;\n    }\n\n    return { results, errors, successCount };\n  }\n\n  /**\n   * Standardized error handling\n   */\n  protected handleError(error: unknown, context?: Record<string, unknown>): never {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    const errorStack = error instanceof Error ? error.stack : undefined;\n\n    this.logger.error(\n      {\n        error: errorMessage,\n        stack: errorStack,\n        context,\n        serviceName: this.serviceName,\n      },\n      'Service operation failed',\n    );\n\n    // Re-throw with service context\n    if (error instanceof Error) {\n      error.message = `${this.serviceName}: ${error.message}`;\n      throw error;\n    }\n\n    throw new Error(`${this.serviceName}: ${errorMessage}`);\n  }\n\n  /**\n   * Validate required parameters\n   */\n  protected validateRequired(params: Record<string, unknown>, required: string[]): void {\n    const missing = required.filter(\n      (key) => params[key] === undefined || params[key] === null || params[key] === '',\n    );\n\n    if (missing.length > 0) {\n      throw new Error(`Missing required parameters: ${missing.join(', ')}`);\n    }\n  }\n\n  /**\n   * Sanitize and validate input data\n   */\n  protected sanitizeInput<T extends Record<string, unknown>>(\n    input: T,\n    schema: Record<keyof T, 'string' | 'number' | 'boolean' | 'object' | 'array'>,\n  ): T {\n    const sanitized = { ...input };\n\n    for (const [key, expectedType] of Object.entries(schema)) {\n      const value = sanitized[key as keyof T];\n\n      if (value === undefined || value === null) continue;\n\n      switch (expectedType) {\n        case 'string':\n          if (typeof value !== 'string') {\n            (sanitized as Record<string, unknown>)[key] = String(value);\n          }\n          // Trim whitespace and limit length\n          (sanitized as Record<string, unknown>)[key] = String(value).trim().slice(0, 1000);\n          break;\n\n        case 'number':\n          if (typeof value !== 'number') {\n            const parsed = Number(value);\n            if (isNaN(parsed)) {\n              throw new Error(`Invalid number value for ${key}: ${value}`);\n            }\n            (sanitized as Record<string, unknown>)[key] = parsed;\n          }\n          break;\n\n        case 'boolean':\n          if (typeof value !== 'boolean') {\n            (sanitized as Record<string, unknown>)[key] = Boolean(value);\n          }\n          break;\n\n        case 'object':\n          if (typeof value !== 'object' || Array.isArray(value)) {\n            throw new Error(`Expected object for ${key}, got ${typeof value}`);\n          }\n          break;\n\n        case 'array':\n          if (!Array.isArray(value)) {\n            throw new Error(`Expected array for ${key}, got ${typeof value}`);\n          }\n          break;\n      }\n    }\n\n    return sanitized;\n  }\n\n  /**\n   * Get service performance metrics\n   */\n  getMetrics(): ServiceMetrics {\n    return { ...this.metrics };\n  }\n\n  /**\n   * Reset service metrics\n   */\n  resetMetrics(): void {\n    this.metrics = {\n      operationCount: 0,\n      errorCount: 0,\n      averageResponseTime: 0,\n      lastOperation: new Date(),\n    };\n  }\n\n  /**\n   * Check service health\n   */\n  async healthCheck(): Promise<{\n    healthy: boolean;\n    details: {\n      database: boolean;\n      metrics: ServiceMetrics;\n      uptime: number;\n    };\n  }> {\n    try {\n      // Test database connection\n      await this.prisma.$queryRaw`SELECT 1`;\n\n      return {\n        healthy: true,\n        details: {\n          database: true,\n          metrics: this.getMetrics(),\n          uptime: Date.now() - this.metrics.lastOperation.getTime(),\n        },\n      };\n    } catch (error) {\n      this.logger.error({ error }, 'Health check failed');\n\n      return {\n        healthy: false,\n        details: {\n          database: false,\n          metrics: this.getMetrics(),\n          uptime: Date.now() - this.metrics.lastOperation.getTime(),\n        },\n      };\n    }\n  }\n\n  // Private helper methods\n\n  private updateMetrics(responseTime: number, isError: boolean): void {\n    this.metrics.operationCount++;\n    this.metrics.lastOperation = new Date();\n\n    if (isError) {\n      this.metrics.errorCount++;\n    }\n\n    // Update rolling average response time\n    const totalTime = this.metrics.averageResponseTime * (this.metrics.operationCount - 1);\n    this.metrics.averageResponseTime = (totalTime + responseTime) / this.metrics.operationCount;\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  private createBatches<T>(items: T[], batchSize: number): T[][] {\n    const batches: T[][] = [];\n    for (let i = 0; i < items.length; i += batchSize) {\n      batches.push(items.slice(i, i + batchSize));\n    }\n    return batches;\n  }\n}\n\nexport default BaseService;\n"],"version":3}