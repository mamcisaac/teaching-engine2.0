{"file":"/Users/michaelmcisaac/GitHub/teaching-engine2.0/server/src/services/clusteringService.ts","mappings":"AAAA,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AACtD,OAAO,EAAE,MAAM,EAAE,MAAM,cAAc,CAAC;AACtC,OAAO,WAAW,MAAM,oBAAoB,CAAC;AAkB7C,MAAM,OAAO,iBAAkB,SAAQ,WAAW;IAC/B,cAAc,GAAsB;QACnD,cAAc,EAAE,CAAC;QACjB,WAAW,EAAE,EAAE;QACf,mBAAmB,EAAE,IAAI;QACzB,gBAAgB,EAAE,IAAI;KACvB,CAAC;IAEF;QACE,KAAK,CAAC,mBAAmB,CAAC,CAAC;IAC7B,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,mBAAmB,CACvB,QAAgB,EAChB,UAAsC,EAAE;QAExC,MAAM,IAAI,GAAG,EAAE,GAAG,IAAI,CAAC,cAAc,EAAE,GAAG,OAAO,EAAE,CAAC;QAEpD,IAAI,CAAC;YACH,6DAA6D;YAC7D,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,6BAA6B,CAAC,QAAQ,CAAC,CAAC;YAExE,IAAI,YAAY,CAAC,MAAM,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;gBAC9C,IAAI,CAAC,MAAM,CAAC,IAAI,CACd,EAAE,QAAQ,EAAE,gBAAgB,EAAE,YAAY,CAAC,MAAM,EAAE,EACnD,uDAAuD,CACxD,CAAC;gBACF,OAAO,EAAE,CAAC;YACZ,CAAC;YAED,IAAI,CAAC,MAAM,CAAC,IAAI,CACd,EAAE,QAAQ,EAAE,gBAAgB,EAAE,YAAY,CAAC,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,EAClE,iCAAiC,CAClC,CAAC;YAEF,kCAAkC;YAClC,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,6BAA6B,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;YAE9E,wDAAwD;YACxD,IAAI,IAAI,CAAC,gBAAgB,EAAE,CAAC;gBAC1B,MAAM,IAAI,CAAC,qBAAqB,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;YACvD,CAAC;YAED,4BAA4B;YAC5B,MAAM,aAAa,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;YAElE,IAAI,CAAC,MAAM,CAAC,IAAI,CACd,EAAE,QAAQ,EAAE,YAAY,EAAE,aAAa,CAAC,MAAM,EAAE,EAChD,kCAAkC,CACnC,CAAC;YAEF,OAAO,aAAa,CAAC;QACvB,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,KAAK,EAAE,QAAQ,EAAE,EAAE,gCAAgC,CAAC,CAAC;YACzE,MAAM,IAAI,KAAK,CAAC,sBAAsB,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;QACzD,CAAC;IACH,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,qBAAqB,CACzB,QAAgB,EAChB,UAAsC,EAAE;QAExC,IAAI,CAAC;YACH,2CAA2C;YAC3C,MAAM,IAAI,CAAC,MAAM,CAAC,kBAAkB,CAAC,UAAU,CAAC;gBAC9C,KAAK,EAAE,EAAE,QAAQ,EAAE;aACpB,CAAC,CAAC;YAEH,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,EAAE,6CAA6C,CAAC,CAAC;YAE9E,yBAAyB;YACzB,OAAO,MAAM,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QAC3D,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,KAAK,EAAE,QAAQ,EAAE,EAAE,mCAAmC,CAAC,CAAC;YAC5E,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,WAAW,CAAC,QAAgB;QAChC,IAAI,CAAC;YACH,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,kBAAkB,CAAC,QAAQ,CAAC;gBAC7D,KAAK,EAAE,EAAE,QAAQ,EAAE;gBACnB,OAAO,EAAE,EAAE,UAAU,EAAE,MAAM,EAAE;aAChC,CAAC,CAAC;YAEH,OAAO,QAAQ,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;gBAChC,EAAE,EAAE,OAAO,CAAC,EAAE;gBACd,IAAI,EAAE,OAAO,CAAC,WAAW;gBACzB,IAAI,EAAE,OAAO,CAAC,WAA4C;gBAC1D,cAAc,EAAE,OAAO,CAAC,cAA0B;gBAClD,UAAU,EAAE,OAAO,CAAC,UAAU;gBAC9B,cAAc,EAAE,OAAO,CAAC,cAAc,IAAI,SAAS;aACpD,CAAC,CAAC,CAAC;QACN,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,KAAK,EAAE,QAAQ,EAAE,EAAE,wBAAwB,CAAC,CAAC;YACjE,OAAO,EAAE,CAAC;QACZ,CAAC;IACH,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,0BAA0B,CAC9B,aAAqB,EACrB,YAAoB,GAAG,EACvB,QAAgB,EAAE;QASlB,IAAI,CAAC;YACH,MAAM,YAAY,GAAG,MAAM,gBAAgB,CAAC,uBAAuB,CACjE,aAAa,EACb,SAAS,EACT,KAAK,CACN,CAAC;YAEF,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC;gBAAE,OAAO,EAAE,CAAC;YAEzC,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,qBAAqB,CAAC,QAAQ,CAAC;gBACpE,KAAK,EAAE;oBACL,EAAE,EAAE,EAAE,EAAE,EAAE,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,aAAa,CAAC,EAAE;iBACrD;gBACD,MAAM,EAAE;oBACN,EAAE,EAAE,IAAI;oBACR,IAAI,EAAE,IAAI;oBACV,WAAW,EAAE,IAAI;iBAClB;aACF,CAAC,CAAC;YAEH,OAAO,YAAY;iBAChB,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE;gBACX,MAAM,WAAW,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,KAAK,GAAG,CAAC,aAAa,CAAC,CAAC;gBACzE,OAAO;oBACL,aAAa,EAAE,GAAG,CAAC,aAAa;oBAChC,IAAI,EAAE,WAAW,EAAE,IAAI,IAAI,SAAS;oBACpC,WAAW,EAAE,WAAW,EAAE,WAAW,IAAI,SAAS;oBAClD,UAAU,EAAE,GAAG,CAAC,UAAU;iBAC3B,CAAC;YACJ,CAAC,CAAC;iBACD,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC;QAC/C,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,KAAK,EAAE,aAAa,EAAE,EAAE,wCAAwC,CAAC,CAAC;YACtF,OAAO,EAAE,CAAC;QACZ,CAAC;IACH,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,qBAAqB,CAAC,QAAgB;QAM1C,IAAI,CAAC;YACH,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;YAElD,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBAC1B,OAAO;oBACL,aAAa,EAAE,CAAC;oBAChB,iBAAiB,EAAE,CAAC;oBACpB,yBAAyB,EAAE,CAAC;oBAC5B,WAAW,EAAE,CAAC,uDAAuD,CAAC;iBACvE,CAAC;YACJ,CAAC;YAED,MAAM,WAAW,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;YACtD,MAAM,iBAAiB,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,WAAW,CAAC,MAAM,CAAC;YACtF,MAAM,yBAAyB,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,UAAU,GAAG,GAAG,CAAC,CAAC,MAAM,CAAC;YAEpF,MAAM,WAAW,GAAa,EAAE,CAAC;YAEjC,IAAI,iBAAiB,GAAG,GAAG,EAAE,CAAC;gBAC5B,WAAW,CAAC,IAAI,CAAC,+DAA+D,CAAC,CAAC;YACpF,CAAC;YAED,IAAI,yBAAyB,GAAG,QAAQ,CAAC,MAAM,GAAG,GAAG,EAAE,CAAC;gBACtD,WAAW,CAAC,IAAI,CAAC,oEAAoE,CAAC,CAAC;YACzF,CAAC;YAED,MAAM,aAAa,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC;YACjF,IAAI,aAAa,GAAG,QAAQ,CAAC,MAAM,GAAG,GAAG,EAAE,CAAC;gBAC1C,WAAW,CAAC,IAAI,CAAC,yEAAyE,CAAC,CAAC;YAC9F,CAAC;YAED,OAAO;gBACL,aAAa,EAAE,QAAQ,CAAC,MAAM;gBAC9B,iBAAiB;gBACjB,yBAAyB;gBACzB,WAAW;aACZ,CAAC;QACJ,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,KAAK,EAAE,QAAQ,EAAE,EAAE,mCAAmC,CAAC,CAAC;YAC5E,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;IAED,yBAAyB;IAEjB,KAAK,CAAC,6BAA6B,CAAC,QAAgB;QAQ1D,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,qBAAqB,CAAC,QAAQ,CAAC;YACpE,KAAK,EAAE,EAAE,QAAQ,EAAE;YACnB,OAAO,EAAE;gBACP,SAAS,EAAE,IAAI;aAChB;SACF,CAAC,CAAC;QAEH,MAAM,0BAA0B,GAAG,YAAY;aAC5C,MAAM,CAAC,CAAC,WAAW,EAAE,EAAE,CAAC,WAAW,CAAC,SAAS,CAAC;aAC9C,GAAG,CAAC,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;YACrB,EAAE,EAAE,WAAW,CAAC,EAAE;YAClB,IAAI,EAAE,WAAW,CAAC,IAAI;YACtB,WAAW,EAAE,WAAW,CAAC,WAAW;YACpC,SAAS,EAAE,WAAW,CAAC,SAAU,CAAC,SAAqB;SACxD,CAAC,CAAC,CAAC;QAEN,8BAA8B;QAC9B,MAAM,iBAAiB,GAAG,YAAY,CAAC,MAAM,CAAC,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;QACvF,IAAI,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACjC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,iBAAiB,CAAC,MAAM,EAAE,EAAE,+BAA+B,CAAC,CAAC;YAEvF,MAAM,aAAa,GAAG,iBAAiB,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;gBAC5D,EAAE,EAAE,WAAW,CAAC,EAAE;gBAClB,IAAI,EAAE,GAAG,WAAW,CAAC,IAAI,KAAK,WAAW,CAAC,WAAW,EAAE;aACxD,CAAC,CAAC,CAAC;YAEJ,MAAM,gBAAgB,CAAC,uBAAuB,CAAC,aAAa,CAAC,CAAC;YAE9D,+BAA+B;YAC/B,MAAM,mBAAmB,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,qBAAqB,CAAC,QAAQ,CAAC;gBAC3E,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,iBAAiB,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;gBACzD,OAAO,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE;aAC7B,CAAC,CAAC;YAEH,KAAK,MAAM,WAAW,IAAI,mBAAmB,EAAE,CAAC;gBAC9C,IAAI,WAAW,CAAC,SAAS,EAAE,CAAC;oBAC1B,0BAA0B,CAAC,IAAI,CAAC;wBAC9B,EAAE,EAAE,WAAW,CAAC,EAAE;wBAClB,IAAI,EAAE,WAAW,CAAC,IAAI;wBACtB,WAAW,EAAE,WAAW,CAAC,WAAW;wBACpC,SAAS,EAAE,WAAW,CAAC,SAAS,CAAC,SAAqB;qBACvD,CAAC,CAAC;gBACL,CAAC;YACH,CAAC;QACH,CAAC;QAED,OAAO,0BAA0B,CAAC;IACpC,CAAC;IAEO,KAAK,CAAC,6BAA6B,CACzC,YAAsF,EACtF,OAA0B;QAS1B,gDAAgD;QAChD,MAAM,QAAQ,GAKR,EAAE,CAAC;QAET,MAAM,IAAI,GAAG,IAAI,GAAG,EAAU,CAAC;QAC/B,MAAM,YAAY,GAAuE,EAAE,CAAC;QAE5F,8CAA8C;QAC9C,KAAK,MAAM,WAAW,IAAI,YAAY,EAAE,CAAC;YACvC,YAAY,CAAC,WAAW,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC;YAClC,KAAK,MAAM,KAAK,IAAI,YAAY,EAAE,CAAC;gBACjC,IAAI,WAAW,CAAC,EAAE,KAAK,KAAK,CAAC,EAAE,EAAE,CAAC;oBAChC,MAAM,UAAU,GAAG,gBAAgB,CAAC,mBAAmB,CACrD,WAAW,CAAC,SAAS,EACrB,KAAK,CAAC,SAAS,CAChB,CAAC;oBACF,YAAY,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,aAAa,EAAE,KAAK,CAAC,EAAE,EAAE,UAAU,EAAE,CAAC,CAAC;gBAC7E,CAAC;YACH,CAAC;YACD,YAAY,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC,UAAU,CAAC,CAAC;QAC3E,CAAC;QAED,yBAAyB;QACzB,KAAK,MAAM,WAAW,IAAI,YAAY,EAAE,CAAC;YACvC,IAAI,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE,CAAC,IAAI,QAAQ,CAAC,MAAM,IAAI,OAAO,CAAC,WAAW;gBAAE,SAAS;YAEjF,MAAM,OAAO,GAAG,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;YACjC,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;YAEzB,mDAAmD;YACnD,MAAM,mBAAmB,GAAG,YAAY,CAAC,WAAW,CAAC,EAAE,CAAC;iBACrD,MAAM,CACL,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,GAAG,CAAC,UAAU,IAAI,OAAO,CAAC,mBAAmB,CACvF;iBACA,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,qBAAqB;YAEtC,KAAK,MAAM,GAAG,IAAI,mBAAmB,EAAE,CAAC;gBACtC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;gBAChC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;YAC9B,CAAC;YAED,IAAI,OAAO,CAAC,MAAM,IAAI,OAAO,CAAC,cAAc,EAAE,CAAC;gBAC7C,oDAAoD;gBACpD,IAAI,eAAe,GAAG,CAAC,CAAC;gBACxB,IAAI,SAAS,GAAG,CAAC,CAAC;gBAElB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBACxC,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;wBAC5C,MAAM,YAAY,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,KAAK,OAAO,CAAC,CAAC,CAAC,CAAE,CAAC;wBACpE,MAAM,YAAY,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,KAAK,OAAO,CAAC,CAAC,CAAC,CAAE,CAAC;wBACpE,eAAe,IAAI,gBAAgB,CAAC,mBAAmB,CACrD,YAAY,CAAC,SAAS,EACtB,YAAY,CAAC,SAAS,CACvB,CAAC;wBACF,SAAS,EAAE,CAAC;oBACd,CAAC;gBACH,CAAC;gBAED,MAAM,UAAU,GAAG,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC,eAAe,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;gBAEnE,uDAAuD;gBACvD,MAAM,WAAW,GAAG,IAAI,CAAC,oBAAoB,CAC3C,OAAO,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,CAAE,CAAC,CAC5D,CAAC;gBAEF,QAAQ,CAAC,IAAI,CAAC;oBACZ,IAAI,EAAE,WAAW,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;oBACtC,IAAI,EAAE,WAAW;oBACjB,cAAc,EAAE,OAAO;oBACvB,UAAU;iBACX,CAAC,CAAC;YACL,CAAC;QACH,CAAC;QAED,OAAO,QAAQ,CAAC;IAClB,CAAC;IAEO,oBAAoB,CAC1B,YAAqD;QAErD,qDAAqD;QACrD,MAAM,YAAY,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,WAAW,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAEpF,IACE,YAAY,CAAC,QAAQ,CAAC,OAAO,CAAC;YAC9B,YAAY,CAAC,QAAQ,CAAC,SAAS,CAAC;YAChC,YAAY,CAAC,QAAQ,CAAC,KAAK,CAAC,EAC5B,CAAC;YACD,OAAO,OAAO,CAAC;QACjB,CAAC;QAED,IACE,YAAY,CAAC,QAAQ,CAAC,SAAS,CAAC;YAChC,YAAY,CAAC,QAAQ,CAAC,YAAY,CAAC;YACnC,YAAY,CAAC,QAAQ,CAAC,WAAW,CAAC,EAClC,CAAC;YACD,OAAO,SAAS,CAAC;QACnB,CAAC;QAED,OAAO,OAAO,CAAC,CAAC,UAAU;IAC5B,CAAC;IAEO,KAAK,CAAC,qBAAqB,CACjC,QAKG,EACH,SAAiB;QAEjB,IAAI,CAAC,MAAM,EAAE,CAAC;YACZ,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,kDAAkD,CAAC,CAAC;YACrE,OAAO;QACT,CAAC;QAED,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;YAC/B,IAAI,CAAC;gBACH,gDAAgD;gBAChD,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,qBAAqB,CAAC,QAAQ,CAAC;oBACpE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,OAAO,CAAC,cAAc,EAAE,EAAE;oBAC7C,MAAM,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,WAAW,EAAE,IAAI,EAAE;iBAC1C,CAAC,CAAC;gBAEH,MAAM,eAAe,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,WAAW,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAE1F,MAAM,MAAM,GAAG;;EAErB,eAAe;;YAEL,CAAC;gBAEL,MAAM,QAAQ,GAAG,MAAM,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;oBACpD,KAAK,EAAE,eAAe;oBACtB,QAAQ,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC;oBAC7C,WAAW,EAAE,GAAG;oBAChB,UAAU,EAAE,EAAE;iBACf,CAAC,CAAC;gBAEH,MAAM,cAAc,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;gBACrE,IAAI,cAAc,EAAE,CAAC;oBACnB,OAAO,CAAC,IAAI,GAAG,cAAc,CAAC;gBAChC,CAAC;YACH,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBACf,IAAI,CAAC,MAAM,CAAC,KAAK,CACf,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,CAAC,cAAc,EAAE,EAC5C,sCAAsC,CACvC,CAAC;YACJ,CAAC;QACH,CAAC;IACH,CAAC;IAEO,KAAK,CAAC,YAAY,CACxB,QAAgB,EAChB,QAKG;QAEH,MAAM,aAAa,GAAoB,EAAE,CAAC;QAE1C,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;YAC/B,IAAI,CAAC;gBACH,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,kBAAkB,CAAC,MAAM,CAAC;oBACxD,IAAI,EAAE;wBACJ,QAAQ;wBACR,WAAW,EAAE,OAAO,CAAC,IAAI;wBACzB,WAAW,EAAE,OAAO,CAAC,IAAI;wBACzB,cAAc,EAAE,OAAO,CAAC,cAAc;wBACtC,UAAU,EAAE,OAAO,CAAC,UAAU;wBAC9B,cAAc,EACZ,OAAO,CAAC,IAAI,KAAK,WAAW,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;4BACzD,CAAC,CAAC,OAAO,CAAC,IAAI;4BACd,CAAC,CAAC,SAAS;qBAChB;iBACF,CAAC,CAAC;gBAEH,aAAa,CAAC,IAAI,CAAC;oBACjB,EAAE,EAAE,KAAK,CAAC,EAAE;oBACZ,IAAI,EAAE,KAAK,CAAC,WAAW;oBACvB,IAAI,EAAE,KAAK,CAAC,WAA4C;oBACxD,cAAc,EAAE,KAAK,CAAC,cAA0B;oBAChD,UAAU,EAAE,KAAK,CAAC,UAAU;oBAC5B,cAAc,EAAE,KAAK,CAAC,cAAc,IAAI,SAAS;iBAClD,CAAC,CAAC;YACL,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,KAAK,EAAE,OAAO,EAAE,EAAE,wBAAwB,CAAC,CAAC;YAClE,CAAC;QACH,CAAC;QAED,OAAO,aAAa,CAAC;IACvB,CAAC;CACF;AAED,4BAA4B;AAC5B,MAAM,CAAC,MAAM,iBAAiB,GAAG,IAAI,iBAAiB,EAAE,CAAC","names":[],"sources":["/Users/michaelmcisaac/GitHub/teaching-engine2.0/server/src/services/clusteringService.ts"],"sourcesContent":["import { embeddingService } from './embeddingService';\nimport { openai } from './llmService';\nimport BaseService from './base/BaseService';\n\nexport interface ClusterResult {\n  id: string;\n  name: string;\n  type: 'theme' | 'skill' | 'concept';\n  expectationIds: string[];\n  confidence: number;\n  suggestedTheme?: string;\n}\n\nexport interface ClusteringOptions {\n  minClusterSize: number;\n  maxClusters: number;\n  similarityThreshold: number;\n  useAISuggestions: boolean;\n}\n\nexport class ClusteringService extends BaseService {\n  private readonly defaultOptions: ClusteringOptions = {\n    minClusterSize: 2,\n    maxClusters: 20,\n    similarityThreshold: 0.75,\n    useAISuggestions: true,\n  };\n\n  constructor() {\n    super('ClusteringService');\n  }\n\n  /**\n   * Cluster curriculum expectations for a specific import using embedding-based similarity\n   */\n  async clusterExpectations(\n    importId: string,\n    options: Partial<ClusteringOptions> = {},\n  ): Promise<ClusterResult[]> {\n    const opts = { ...this.defaultOptions, ...options };\n\n    try {\n      // Get all expectations for this import with their embeddings\n      const expectations = await this.getExpectationsWithEmbeddings(importId);\n\n      if (expectations.length < opts.minClusterSize) {\n        this.logger.info(\n          { importId, expectationCount: expectations.length },\n          'Not enough expectations to create meaningful clusters',\n        );\n        return [];\n      }\n\n      this.logger.info(\n        { importId, expectationCount: expectations.length, options: opts },\n        'Starting expectation clustering',\n      );\n\n      // Perform hierarchical clustering\n      const clusters = await this.performHierarchicalClustering(expectations, opts);\n\n      // Generate AI suggestions for cluster themes if enabled\n      if (opts.useAISuggestions) {\n        await this.generateClusterThemes(clusters, importId);\n      }\n\n      // Save clusters to database\n      const savedClusters = await this.saveClusters(importId, clusters);\n\n      this.logger.info(\n        { importId, clusterCount: savedClusters.length },\n        'Completed expectation clustering',\n      );\n\n      return savedClusters;\n    } catch (error) {\n      this.logger.error({ error, importId }, 'Failed to cluster expectations');\n      throw new Error(`Clustering failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Re-cluster expectations with different parameters\n   */\n  async reclusterExpectations(\n    importId: string,\n    options: Partial<ClusteringOptions> = {},\n  ): Promise<ClusterResult[]> {\n    try {\n      // Delete existing clusters for this import\n      await this.prisma.expectationCluster.deleteMany({\n        where: { importId },\n      });\n\n      this.logger.info({ importId }, 'Deleted existing clusters for re-clustering');\n\n      // Perform new clustering\n      return await this.clusterExpectations(importId, options);\n    } catch (error) {\n      this.logger.error({ error, importId }, 'Failed to re-cluster expectations');\n      throw error;\n    }\n  }\n\n  /**\n   * Get clusters for a specific import\n   */\n  async getClusters(importId: string): Promise<ClusterResult[]> {\n    try {\n      const clusters = await this.prisma.expectationCluster.findMany({\n        where: { importId },\n        orderBy: { confidence: 'desc' },\n      });\n\n      return clusters.map((cluster) => ({\n        id: cluster.id,\n        name: cluster.clusterName,\n        type: cluster.clusterType as 'theme' | 'skill' | 'concept',\n        expectationIds: cluster.expectationIds as string[],\n        confidence: cluster.confidence,\n        suggestedTheme: cluster.suggestedTheme || undefined,\n      }));\n    } catch (error) {\n      this.logger.error({ error, importId }, 'Failed to get clusters');\n      return [];\n    }\n  }\n\n  /**\n   * Suggest similar expectations based on a given expectation\n   */\n  async suggestSimilarExpectations(\n    expectationId: string,\n    threshold: number = 0.8,\n    limit: number = 10,\n  ): Promise<\n    {\n      expectationId: string;\n      code: string;\n      description: string;\n      similarity: number;\n    }[]\n  > {\n    try {\n      const similarities = await embeddingService.findSimilarExpectations(\n        expectationId,\n        threshold,\n        limit,\n      );\n\n      if (similarities.length === 0) return [];\n\n      const expectations = await this.prisma.curriculumExpectation.findMany({\n        where: {\n          id: { in: similarities.map((s) => s.expectationId) },\n        },\n        select: {\n          id: true,\n          code: true,\n          description: true,\n        },\n      });\n\n      return similarities\n        .map((sim) => {\n          const expectation = expectations.find((e) => e.id === sim.expectationId);\n          return {\n            expectationId: sim.expectationId,\n            code: expectation?.code || 'Unknown',\n            description: expectation?.description || 'Unknown',\n            similarity: sim.similarity,\n          };\n        })\n        .filter((item) => item.code !== 'Unknown');\n    } catch (error) {\n      this.logger.error({ error, expectationId }, 'Failed to suggest similar expectations');\n      return [];\n    }\n  }\n\n  /**\n   * Analyze cluster quality and suggest improvements\n   */\n  async analyzeClusterQuality(importId: string): Promise<{\n    totalClusters: number;\n    averageConfidence: number;\n    clustersWithLowConfidence: number;\n    suggestions: string[];\n  }> {\n    try {\n      const clusters = await this.getClusters(importId);\n\n      if (clusters.length === 0) {\n        return {\n          totalClusters: 0,\n          averageConfidence: 0,\n          clustersWithLowConfidence: 0,\n          suggestions: ['No clusters found. Consider running clustering first.'],\n        };\n      }\n\n      const confidences = clusters.map((c) => c.confidence);\n      const averageConfidence = confidences.reduce((a, b) => a + b, 0) / confidences.length;\n      const clustersWithLowConfidence = clusters.filter((c) => c.confidence < 0.6).length;\n\n      const suggestions: string[] = [];\n\n      if (averageConfidence < 0.7) {\n        suggestions.push('Consider adjusting similarity threshold for better clustering');\n      }\n\n      if (clustersWithLowConfidence > clusters.length * 0.3) {\n        suggestions.push('Many clusters have low confidence - consider reducing max clusters');\n      }\n\n      const smallClusters = clusters.filter((c) => c.expectationIds.length < 3).length;\n      if (smallClusters > clusters.length * 0.5) {\n        suggestions.push('Many small clusters detected - consider increasing minimum cluster size');\n      }\n\n      return {\n        totalClusters: clusters.length,\n        averageConfidence,\n        clustersWithLowConfidence,\n        suggestions,\n      };\n    } catch (error) {\n      this.logger.error({ error, importId }, 'Failed to analyze cluster quality');\n      throw error;\n    }\n  }\n\n  // Private helper methods\n\n  private async getExpectationsWithEmbeddings(importId: string): Promise<\n    {\n      id: string;\n      code: string;\n      description: string;\n      embedding: number[];\n    }[]\n  > {\n    const expectations = await this.prisma.curriculumExpectation.findMany({\n      where: { importId },\n      include: {\n        embedding: true,\n      },\n    });\n\n    const expectationsWithEmbeddings = expectations\n      .filter((expectation) => expectation.embedding)\n      .map((expectation) => ({\n        id: expectation.id,\n        code: expectation.code,\n        description: expectation.description,\n        embedding: expectation.embedding!.embedding as number[],\n      }));\n\n    // Generate missing embeddings\n    const missingEmbeddings = expectations.filter((expectation) => !expectation.embedding);\n    if (missingEmbeddings.length > 0) {\n      this.logger.info({ count: missingEmbeddings.length }, 'Generating missing embeddings');\n\n      const embeddingData = missingEmbeddings.map((expectation) => ({\n        id: expectation.id,\n        text: `${expectation.code}: ${expectation.description}`,\n      }));\n\n      await embeddingService.generateBatchEmbeddings(embeddingData);\n\n      // Re-fetch with new embeddings\n      const updatedExpectations = await this.prisma.curriculumExpectation.findMany({\n        where: { id: { in: missingEmbeddings.map((e) => e.id) } },\n        include: { embedding: true },\n      });\n\n      for (const expectation of updatedExpectations) {\n        if (expectation.embedding) {\n          expectationsWithEmbeddings.push({\n            id: expectation.id,\n            code: expectation.code,\n            description: expectation.description,\n            embedding: expectation.embedding.embedding as number[],\n          });\n        }\n      }\n    }\n\n    return expectationsWithEmbeddings;\n  }\n\n  private async performHierarchicalClustering(\n    expectations: { id: string; code: string; description: string; embedding: number[] }[],\n    options: ClusteringOptions,\n  ): Promise<\n    {\n      name: string;\n      type: 'theme' | 'skill' | 'concept';\n      expectationIds: string[];\n      confidence: number;\n    }[]\n  > {\n    // Simple hierarchical clustering implementation\n    const clusters: {\n      name: string;\n      type: 'theme' | 'skill' | 'concept';\n      expectationIds: string[];\n      confidence: number;\n    }[] = [];\n\n    const used = new Set<string>();\n    const similarities: { [key: string]: { expectationId: string; similarity: number }[] } = {};\n\n    // Calculate similarities for all expectations\n    for (const expectation of expectations) {\n      similarities[expectation.id] = [];\n      for (const other of expectations) {\n        if (expectation.id !== other.id) {\n          const similarity = embeddingService.calculateSimilarity(\n            expectation.embedding,\n            other.embedding,\n          );\n          similarities[expectation.id].push({ expectationId: other.id, similarity });\n        }\n      }\n      similarities[expectation.id].sort((a, b) => b.similarity - a.similarity);\n    }\n\n    // Form clusters greedily\n    for (const expectation of expectations) {\n      if (used.has(expectation.id) || clusters.length >= options.maxClusters) continue;\n\n      const cluster = [expectation.id];\n      used.add(expectation.id);\n\n      // Find similar expectations to add to this cluster\n      const similarExpectations = similarities[expectation.id]\n        .filter(\n          (sim) => !used.has(sim.expectationId) && sim.similarity >= options.similarityThreshold,\n        )\n        .slice(0, 10); // Limit cluster size\n\n      for (const sim of similarExpectations) {\n        cluster.push(sim.expectationId);\n        used.add(sim.expectationId);\n      }\n\n      if (cluster.length >= options.minClusterSize) {\n        // Calculate cluster confidence (average similarity)\n        let totalSimilarity = 0;\n        let pairCount = 0;\n\n        for (let i = 0; i < cluster.length; i++) {\n          for (let j = i + 1; j < cluster.length; j++) {\n            const expectation1 = expectations.find((e) => e.id === cluster[i])!;\n            const expectation2 = expectations.find((e) => e.id === cluster[j])!;\n            totalSimilarity += embeddingService.calculateSimilarity(\n              expectation1.embedding,\n              expectation2.embedding,\n            );\n            pairCount++;\n          }\n        }\n\n        const confidence = pairCount > 0 ? totalSimilarity / pairCount : 0;\n\n        // Determine cluster type based on expectation patterns\n        const clusterType = this.determineClusterType(\n          cluster.map((id) => expectations.find((e) => e.id === id)!),\n        );\n\n        clusters.push({\n          name: `Cluster ${clusters.length + 1}`,\n          type: clusterType,\n          expectationIds: cluster,\n          confidence,\n        });\n      }\n    }\n\n    return clusters;\n  }\n\n  private determineClusterType(\n    expectations: { code: string; description: string }[],\n  ): 'theme' | 'skill' | 'concept' {\n    // Simple heuristic based on expectation descriptions\n    const descriptions = expectations.map((e) => e.description.toLowerCase()).join(' ');\n\n    if (\n      descriptions.includes('skill') ||\n      descriptions.includes('ability') ||\n      descriptions.includes('can')\n    ) {\n      return 'skill';\n    }\n\n    if (\n      descriptions.includes('concept') ||\n      descriptions.includes('understand') ||\n      descriptions.includes('knowledge')\n    ) {\n      return 'concept';\n    }\n\n    return 'theme'; // Default\n  }\n\n  private async generateClusterThemes(\n    clusters: {\n      name: string;\n      type: 'theme' | 'skill' | 'concept';\n      expectationIds: string[];\n      confidence: number;\n    }[],\n    _importId: string,\n  ): Promise<void> {\n    if (!openai) {\n      this.logger.warn('OpenAI not configured, skipping theme generation');\n      return;\n    }\n\n    for (const cluster of clusters) {\n      try {\n        // Get expectation descriptions for this cluster\n        const expectations = await this.prisma.curriculumExpectation.findMany({\n          where: { id: { in: cluster.expectationIds } },\n          select: { code: true, description: true },\n        });\n\n        const expectationList = expectations.map((e) => `${e.code}: ${e.description}`).join('\\n');\n\n        const prompt = `Given these related curriculum expectations, suggest a concise theme name (2-4 words) that captures their common focus:\n\n${expectationList}\n\nTheme name:`;\n\n        const response = await openai.chat.completions.create({\n          model: 'gpt-3.5-turbo',\n          messages: [{ role: 'user', content: prompt }],\n          temperature: 0.3,\n          max_tokens: 50,\n        });\n\n        const suggestedTheme = response.choices[0]?.message?.content?.trim();\n        if (suggestedTheme) {\n          cluster.name = suggestedTheme;\n        }\n      } catch (error) {\n        this.logger.error(\n          { error, clusterId: cluster.expectationIds },\n          'Failed to generate theme for cluster',\n        );\n      }\n    }\n  }\n\n  private async saveClusters(\n    importId: string,\n    clusters: {\n      name: string;\n      type: 'theme' | 'skill' | 'concept';\n      expectationIds: string[];\n      confidence: number;\n    }[],\n  ): Promise<ClusterResult[]> {\n    const savedClusters: ClusterResult[] = [];\n\n    for (const cluster of clusters) {\n      try {\n        const saved = await this.prisma.expectationCluster.create({\n          data: {\n            importId,\n            clusterName: cluster.name,\n            clusterType: cluster.type,\n            expectationIds: cluster.expectationIds,\n            confidence: cluster.confidence,\n            suggestedTheme:\n              cluster.name !== `Cluster ${clusters.indexOf(cluster) + 1}`\n                ? cluster.name\n                : undefined,\n          },\n        });\n\n        savedClusters.push({\n          id: saved.id,\n          name: saved.clusterName,\n          type: saved.clusterType as 'theme' | 'skill' | 'concept',\n          expectationIds: saved.expectationIds as string[],\n          confidence: saved.confidence,\n          suggestedTheme: saved.suggestedTheme || undefined,\n        });\n      } catch (error) {\n        this.logger.error({ error, cluster }, 'Failed to save cluster');\n      }\n    }\n\n    return savedClusters;\n  }\n}\n\n// Export singleton instance\nexport const clusteringService = new ClusteringService();\n"],"version":3}