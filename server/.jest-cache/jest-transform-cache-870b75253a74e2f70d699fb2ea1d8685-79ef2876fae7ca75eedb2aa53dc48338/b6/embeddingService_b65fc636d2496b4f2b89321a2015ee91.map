{"file":"/Users/michaelmcisaac/GitHub/teaching-engine2.0/server/src/services/embeddingService.ts","mappings":"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","names":[],"sources":["/Users/michaelmcisaac/GitHub/teaching-engine2.0/server/src/services/embeddingService.ts"],"sourcesContent":["import { openai } from './llmService';\nimport BaseService from './base/BaseService';\n\nexport interface EmbeddingResult {\n  expectationId: string;\n  embedding: number[];\n  model: string;\n}\n\nexport class EmbeddingService extends BaseService {\n  private readonly model = 'text-embedding-3-small';\n  private readonly batchSize = 100; // OpenAI API batch limit\n  private readonly maxRetries = 3;\n  private readonly retryDelay = 1000; // ms\n\n  constructor() {\n    super('EmbeddingService');\n  }\n\n  /**\n   * Check if embedding service is available\n   */\n  isEmbeddingServiceAvailable(): boolean {\n    return !!openai;\n  }\n\n  /**\n   * Generate embedding for a single curriculum expectation\n   */\n  async generateEmbedding(expectationId: string, text: string): Promise<EmbeddingResult | null> {\n    if (!openai) {\n      this.logger.warn('OpenAI API key not configured, skipping embedding generation');\n      return null;\n    }\n\n    try {\n      // Check if embedding already exists\n      const existing = await this.prisma.curriculumExpectationEmbedding.findUnique({\n        where: { expectationId },\n      });\n\n      if (existing) {\n        this.logger.debug({ expectationId }, 'Embedding already exists for expectation');\n        return {\n          expectationId,\n          embedding: existing.embedding as number[],\n          model: existing.model,\n        };\n      }\n\n      const embedding = await this.generateEmbeddingVector(text);\n      if (!embedding) return null;\n\n      // Store in database\n      await this.prisma.curriculumExpectationEmbedding.create({\n        data: {\n          expectationId,\n          embedding,\n          model: this.model,\n        },\n      });\n\n      this.logger.info(\n        { expectationId, model: this.model },\n        'Generated and stored embedding for expectation',\n      );\n\n      return {\n        expectationId,\n        embedding,\n        model: this.model,\n      };\n    } catch (error) {\n      this.logger.error({ error, expectationId }, 'Failed to generate embedding for expectation');\n      return null;\n    }\n  }\n\n  /**\n   * Generate embeddings for multiple expectations in batches\n   */\n  async generateBatchEmbeddings(\n    expectations: { id: string; text: string }[],\n  ): Promise<EmbeddingResult[]> {\n    if (!openai) {\n      this.logger.warn('OpenAI API key not configured, skipping batch embedding generation');\n      return [];\n    }\n\n    const results: EmbeddingResult[] = [];\n    const batches = this.createEmbeddingBatches(expectations, this.batchSize);\n\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      this.logger.info(\n        { batchIndex: i + 1, totalBatches: batches.length, batchSize: batch.length },\n        'Processing embedding batch',\n      );\n\n      try {\n        const batchResults = await this.processBatch(batch);\n        results.push(...batchResults);\n\n        // Add delay between batches to respect rate limits\n        if (i < batches.length - 1) {\n          await this.sleepEmbed(this.retryDelay);\n        }\n      } catch (error) {\n        this.logger.error({ error, batchIndex: i + 1 }, 'Failed to process embedding batch');\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Get embedding for an expectation (from cache or generate new)\n   */\n  async getEmbedding(expectationId: string): Promise<number[] | null> {\n    try {\n      const embedding = await this.prisma.curriculumExpectationEmbedding.findUnique({\n        where: { expectationId },\n      });\n\n      return embedding ? (embedding.embedding as number[]) : null;\n    } catch (error) {\n      this.logger.error({ error, expectationId }, 'Failed to get embedding for expectation');\n      return null;\n    }\n  }\n\n  /**\n   * Calculate cosine similarity between two embeddings\n   */\n  calculateSimilarity(embedding1: number[], embedding2: number[]): number {\n    if (embedding1.length !== embedding2.length) {\n      throw new Error('Embeddings must have the same length');\n    }\n\n    let dotProduct = 0;\n    let norm1 = 0;\n    let norm2 = 0;\n\n    for (let i = 0; i < embedding1.length; i++) {\n      dotProduct += embedding1[i] * embedding2[i];\n      norm1 += embedding1[i] * embedding1[i];\n      norm2 += embedding2[i] * embedding2[i];\n    }\n\n    norm1 = Math.sqrt(norm1);\n    norm2 = Math.sqrt(norm2);\n\n    if (norm1 === 0 || norm2 === 0) {\n      return 0;\n    }\n\n    return dotProduct / (norm1 * norm2);\n  }\n\n  /**\n   * Find similar expectations based on embedding similarity\n   */\n  async findSimilarExpectations(\n    expectationId: string,\n    threshold: number = 0.8,\n    limit: number = 10,\n  ): Promise<\n    {\n      expectationId: string;\n      similarity: number;\n      expectation?: {\n        id: string;\n        code: string;\n        description: string;\n        subject: string;\n        grade: number;\n      };\n    }[]\n  > {\n    try {\n      const targetEmbedding = await this.getEmbedding(expectationId);\n      if (!targetEmbedding) return [];\n\n      // Get all embeddings with expectation data (optimized for current dataset size)\n      const allEmbeddings = await this.prisma.curriculumExpectationEmbedding.findMany({\n        where: {\n          expectationId: { not: expectationId },\n        },\n        include: {\n          expectation: true,\n        },\n      });\n\n      const similarities = allEmbeddings\n        .map((emb) => ({\n          expectationId: emb.expectationId,\n          similarity: this.calculateSimilarity(targetEmbedding, emb.embedding as number[]),\n          expectation: {\n            id: emb.expectation.id,\n            code: emb.expectation.code,\n            description: emb.expectation.description,\n            subject: emb.expectation.subject,\n            grade: emb.expectation.grade,\n          },\n        }))\n        .filter((item) => item.similarity >= threshold)\n        .sort((a, b) => b.similarity - a.similarity)\n        .slice(0, limit);\n\n      return similarities;\n    } catch (error) {\n      this.logger.error({ error, expectationId }, 'Failed to find similar expectations');\n      return [];\n    }\n  }\n\n  /**\n   * Generate embeddings for all expectations missing them\n   */\n  async generateMissingEmbeddings(forceRegenerate: boolean = false): Promise<number> {\n    try {\n      if (!openai) {\n        this.logger.warn('OpenAI API key not configured');\n        return 0;\n      }\n\n      let expectations;\n      if (forceRegenerate) {\n        // Get all expectations\n        expectations = await this.prisma.curriculumExpectation.findMany({\n          select: { id: true, code: true, description: true },\n        });\n      } else {\n        // Get expectations without embeddings\n        expectations = await this.prisma.curriculumExpectation.findMany({\n          where: {\n            embedding: null,\n          },\n          select: { id: true, code: true, description: true },\n        });\n      }\n\n      if (expectations.length === 0) {\n        this.logger.info('No expectations need embeddings');\n        return 0;\n      }\n\n      this.logger.info({ count: expectations.length }, 'Found expectations needing embeddings');\n\n      // Prepare data for batch processing\n      const expectationData = expectations.map((expectation) => ({\n        id: expectation.id,\n        text: `${expectation.code}: ${expectation.description}`,\n      }));\n\n      const results = await this.generateBatchEmbeddings(expectationData);\n\n      this.logger.info(\n        { total: expectations.length, generated: results.length },\n        'Finished generating embeddings',\n      );\n\n      return results.length;\n    } catch (error) {\n      this.logger.error({ error }, 'Failed to generate missing embeddings');\n      return 0;\n    }\n  }\n\n  /**\n   * Search expectations by text similarity\n   */\n  async searchExpectationsByText(\n    searchText: string,\n    limit: number = 20,\n    threshold: number = 0.7,\n  ): Promise<\n    {\n      expectationId: string;\n      similarity: number;\n      expectation: {\n        id: string;\n        code: string;\n        description: string;\n        subject: string;\n        grade: number;\n      };\n    }[]\n  > {\n    try {\n      if (!openai) {\n        this.logger.warn('OpenAI API key not configured');\n        return [];\n      }\n\n      // Generate embedding for search text\n      const searchEmbedding = await this.generateEmbeddingVector(searchText);\n      if (!searchEmbedding) return [];\n\n      // Get all embeddings with expectation data\n      const allEmbeddings = await this.prisma.curriculumExpectationEmbedding.findMany({\n        include: {\n          expectation: true,\n        },\n      });\n\n      const similarities = allEmbeddings\n        .map((emb) => ({\n          expectationId: emb.expectationId,\n          similarity: this.calculateSimilarity(searchEmbedding, emb.embedding as number[]),\n          expectation: {\n            id: emb.expectation.id,\n            code: emb.expectation.code,\n            description: emb.expectation.description,\n            subject: emb.expectation.subject,\n            grade: emb.expectation.grade,\n          },\n        }))\n        .filter((item) => item.similarity >= threshold)\n        .sort((a, b) => b.similarity - a.similarity)\n        .slice(0, limit);\n\n      return similarities;\n    } catch (error) {\n      this.logger.error({ error, searchText }, 'Failed to search expectations by text');\n      return [];\n    }\n  }\n\n  /**\n   * Get or create embedding for a specific expectation\n   */\n  async getOrCreateExpectationEmbedding(expectationId: string): Promise<EmbeddingResult | null> {\n    try {\n      // Check if embedding exists\n      const existing = await this.prisma.curriculumExpectationEmbedding.findUnique({\n        where: { expectationId },\n      });\n\n      if (existing) {\n        return {\n          expectationId,\n          embedding: existing.embedding as number[],\n          model: existing.model,\n        };\n      }\n\n      // Get expectation details\n      const expectation = await this.prisma.curriculumExpectation.findUnique({\n        where: { id: expectationId },\n        select: { code: true, description: true },\n      });\n\n      if (!expectation) {\n        throw new Error(`Expectation ${expectationId} not found`);\n      }\n\n      // Generate embedding\n      const text = `${expectation.code}: ${expectation.description}`;\n      return await this.generateEmbedding(expectationId, text);\n    } catch (error) {\n      this.logger.error({ error, expectationId }, 'Failed to get or create expectation embedding');\n      return null;\n    }\n  }\n\n  /**\n   * Cleanup old embeddings for a specific model\n   */\n  async cleanupOldEmbeddings(model: string): Promise<number> {\n    try {\n      const result = await this.prisma.curriculumExpectationEmbedding.deleteMany({\n        where: { model: { not: model } },\n      });\n\n      this.logger.info(\n        { deletedCount: result.count, currentModel: model },\n        'Cleaned up old embeddings',\n      );\n\n      return result.count;\n    } catch (error) {\n      this.logger.error({ error, model }, 'Failed to cleanup old embeddings');\n      return 0;\n    }\n  }\n\n  // Private helper methods\n\n  async generateEmbeddingVector(text: string): Promise<number[] | null> {\n    if (!openai) return null;\n\n    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {\n      try {\n        const response = await openai.embeddings.create({\n          model: this.model,\n          input: text,\n          encoding_format: 'float',\n        });\n\n        if (response.usage?.total_tokens) {\n          this.logger.debug({ tokens: response.usage.total_tokens }, 'Embedding tokens used');\n        }\n\n        return response.data[0].embedding;\n      } catch (error: unknown) {\n        this.logger.warn(\n          {\n            error: error instanceof Error ? error.message : String(error),\n            attempt,\n            maxRetries: this.maxRetries,\n          },\n          'Embedding generation attempt failed',\n        );\n\n        if (attempt === this.maxRetries) {\n          this.logger.error({ error }, 'All embedding generation attempts failed');\n          return null;\n        }\n\n        // Exponential backoff\n        await this.sleepEmbed(this.retryDelay * Math.pow(2, attempt - 1));\n      }\n    }\n\n    return null;\n  }\n\n  private async processBatch(batch: { id: string; text: string }[]): Promise<EmbeddingResult[]> {\n    const results: EmbeddingResult[] = [];\n\n    // Check for existing embeddings\n    const existingEmbeddings = await this.prisma.curriculumExpectationEmbedding.findMany({\n      where: {\n        expectationId: { in: batch.map((item) => item.id) },\n      },\n    });\n\n    const existingIds = new Set(existingEmbeddings.map((emb) => emb.expectationId));\n    const newItems = batch.filter((item) => !existingIds.has(item.id));\n\n    // Add existing embeddings to results\n    for (const existing of existingEmbeddings) {\n      results.push({\n        expectationId: existing.expectationId,\n        embedding: existing.embedding as number[],\n        model: existing.model,\n      });\n    }\n\n    if (newItems.length === 0) {\n      return results;\n    }\n\n    // Generate embeddings for new items\n    try {\n      const response = await openai!.embeddings.create({\n        model: this.model,\n        input: newItems.map((item) => item.text),\n        encoding_format: 'float',\n      });\n\n      // Store new embeddings\n      const embeddings = response.data.map((embedding, index) => ({\n        expectationId: newItems[index].id,\n        embedding: embedding.embedding,\n        model: this.model,\n      }));\n\n      await this.prisma.curriculumExpectationEmbedding.createMany({\n        data: embeddings,\n      });\n\n      results.push(...embeddings);\n\n      this.logger.info(\n        { newEmbeddings: newItems.length, totalTokens: response.usage?.total_tokens },\n        'Generated batch embeddings',\n      );\n    } catch (error) {\n      this.logger.error(\n        { error, batchSize: newItems.length },\n        'Failed to generate batch embeddings',\n      );\n    }\n\n    return results;\n  }\n\n  private createEmbeddingBatches<T>(items: T[], batchSize: number): T[][] {\n    const batches: T[][] = [];\n    for (let i = 0; i < items.length; i += batchSize) {\n      batches.push(items.slice(i, i + batchSize));\n    }\n    return batches;\n  }\n\n  private sleepEmbed(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n\n// Export singleton instance\nexport const embeddingService = new EmbeddingService();\n"],"version":3}