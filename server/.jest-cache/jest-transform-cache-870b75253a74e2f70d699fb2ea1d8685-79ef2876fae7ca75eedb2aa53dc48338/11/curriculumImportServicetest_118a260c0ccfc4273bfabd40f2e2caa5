f3880f2eedf7add59302dcb24d54b0fc
import { describe, test, expect, beforeEach, jest } from '@jest/globals';
// Mock Prisma
jest.mock('../../src/prisma', () => ({
    prisma: {
        curriculumImport: {
            create: jest.fn(),
            update: jest.fn(),
            findUnique: jest.fn(),
            findMany: jest.fn(),
        },
        curriculumExpectation: {
            createMany: jest.fn(),
            findMany: jest.fn(),
        },
        expectationCluster: {
            createMany: jest.fn(),
        },
        $transaction: jest.fn(),
    },
}));
// Mock external services
jest.mock('../../src/services/embeddingService', () => ({
    embeddingService: {
        generateEmbedding: jest.fn().mockResolvedValue([0.1, 0.2, 0.3]),
        generateBatchEmbeddings: jest.fn().mockResolvedValue([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]),
    },
}));
jest.mock('../../src/services/clusteringService', () => ({
    clusteringService: {
        clusterExpectations: jest.fn().mockResolvedValue([
            {
                clusterName: 'Number Operations',
                clusterType: 'concept',
                expectationIds: ['exp1', 'exp2'],
                confidence: 0.85,
            },
        ]),
    },
}));
import { CurriculumImportService } from '../../src/services/curriculumImportService';
import { prisma } from '../../src/prisma';
const mockPrisma = prisma;
describe('CurriculumImportService', () => {
    let curriculumImportService;
    beforeEach(() => {
        jest.clearAllMocks();
        curriculumImportService = new CurriculumImportService();
    });
    describe('createImport', () => {
        test('should create new curriculum import', async () => {
            const userId = 1;
            const importData = {
                filename: 'test-curriculum.pdf',
                originalName: 'Grade 1 Math Curriculum.pdf',
                grade: 1,
                subject: 'Mathematics',
            };
            const mockImport = {
                id: 'import1',
                userId,
                ...importData,
                status: 'UPLOADING',
                createdAt: new Date(),
            };
            mockPrisma.curriculumImport.create.mockResolvedValue(mockImport);
            const result = await curriculumImportService.createImport(userId, importData);
            expect(result).toEqual(mockImport);
            expect(mockPrisma.curriculumImport.create).toHaveBeenCalledWith({
                data: {
                    userId,
                    ...importData,
                    status: 'UPLOADING',
                },
            });
        });
    });
    describe('updateImportStatus', () => {
        test('should update import status and metadata', async () => {
            const importId = 'import1';
            const status = 'PROCESSING';
            const metadata = { step: 'parsing_pdf' };
            const mockUpdatedImport = {
                id: importId,
                status,
                metadata,
                updatedAt: new Date(),
            };
            mockPrisma.curriculumImport.update.mockResolvedValue(mockUpdatedImport);
            const result = await curriculumImportService.updateImportStatus(importId, status, metadata);
            expect(result).toEqual(mockUpdatedImport);
            expect(mockPrisma.curriculumImport.update).toHaveBeenCalledWith({
                where: { id: importId },
                data: {
                    status,
                    metadata,
                    updatedAt: expect.any(Date),
                },
            });
        });
        test('should handle processing completion', async () => {
            const importId = 'import1';
            const status = 'COMPLETED';
            mockPrisma.curriculumImport.update.mockResolvedValue({
                id: importId,
                status,
                processedAt: expect.any(Date),
                completedAt: expect.any(Date),
            });
            await curriculumImportService.updateImportStatus(importId, status);
            expect(mockPrisma.curriculumImport.update).toHaveBeenCalledWith({
                where: { id: importId },
                data: {
                    status,
                    processedAt: expect.any(Date),
                    completedAt: expect.any(Date),
                    updatedAt: expect.any(Date),
                },
            });
        });
    });
    describe('parseTextContent', () => {
        test('should parse curriculum text into structured expectations', async () => {
            const importId = 'import1';
            const rawText = `
        A1.1 - Students will demonstrate understanding of numbers 1-10
        A1.2 - Students will count objects accurately up to 20
        B2.1 - Students will identify and extend simple patterns
      `;
            const mockImport = {
                id: importId,
                grade: 1,
                subject: 'Mathematics',
            };
            mockPrisma.curriculumImport.findUnique.mockResolvedValue(mockImport);
            mockPrisma.curriculumImport.update.mockResolvedValue({});
            mockPrisma.$transaction.mockImplementation(async (callback) => {
                return await callback(mockPrisma);
            });
            mockPrisma.curriculumExpectation.createMany.mockResolvedValue({ count: 3 });
            const result = await curriculumImportService.parseTextContent(importId, rawText);
            expect(result.processedCount).toBe(3);
            expect(result.expectations).toHaveLength(3);
            expect(result.expectations[0].code).toBe('A1.1');
            expect(result.expectations[0].description).toBe('Students will demonstrate understanding of numbers 1-10');
            expect(result.expectations[1].code).toBe('A1.2');
            expect(result.expectations[2].code).toBe('B2.1');
        });
        test('should handle malformed text gracefully', async () => {
            const importId = 'import1';
            const rawText = `
        Invalid line without proper format
        A1.1 - Valid expectation
        Another invalid line
      `;
            const mockImport = {
                id: importId,
                grade: 1,
                subject: 'Mathematics',
            };
            mockPrisma.curriculumImport.findUnique.mockResolvedValue(mockImport);
            mockPrisma.curriculumImport.update.mockResolvedValue({});
            mockPrisma.$transaction.mockImplementation(async (callback) => {
                return await callback(mockPrisma);
            });
            mockPrisma.curriculumExpectation.createMany.mockResolvedValue({ count: 1 });
            const result = await curriculumImportService.parseTextContent(importId, rawText);
            expect(result.processedCount).toBe(1);
            expect(result.expectations).toHaveLength(1);
            expect(result.expectations[0].code).toBe('A1.1');
            expect(result.errors).toHaveLength(2); // Two invalid lines
        });
    });
    describe('processCSVContent', () => {
        test('should parse CSV curriculum data', async () => {
            const importId = 'import1';
            const csvContent = `code,description,strand,substrand,grade,subject
A1.1,"Students will demonstrate understanding of numbers 1-10","Number Sense","Counting",1,"Mathematics"
A1.2,"Students will count objects accurately up to 20","Number Sense","Counting",1,"Mathematics"
B2.1,"Students will identify and extend simple patterns","Patterns","Simple Patterns",1,"Mathematics"`;
            const mockImport = {
                id: importId,
                grade: 1,
                subject: 'Mathematics',
            };
            mockPrisma.curriculumImport.findUnique.mockResolvedValue(mockImport);
            mockPrisma.curriculumImport.update.mockResolvedValue({});
            mockPrisma.$transaction.mockImplementation(async (callback) => {
                return await callback(mockPrisma);
            });
            mockPrisma.curriculumExpectation.createMany.mockResolvedValue({ count: 3 });
            const result = await curriculumImportService.processCSVContent(importId, csvContent);
            expect(result.processedCount).toBe(3);
            expect(result.expectations).toHaveLength(3);
            expect(result.expectations[0].strand).toBe('Number Sense');
            expect(result.expectations[0].substrand).toBe('Counting');
            expect(result.expectations[2].strand).toBe('Patterns');
        });
        test('should handle missing required columns', async () => {
            const importId = 'import1';
            const csvContent = `description,strand
"Students will demonstrate understanding of numbers 1-10","Number Sense"`;
            const mockImport = {
                id: importId,
                grade: 1,
                subject: 'Mathematics',
            };
            mockPrisma.curriculumImport.findUnique.mockResolvedValue(mockImport);
            await expect(curriculumImportService.processCSVContent(importId, csvContent)).rejects.toThrow('Missing required columns');
        });
    });
    describe('generateClusters', () => {
        test('should create expectation clusters using AI', async () => {
            const importId = 'import1';
            const mockExpectations = [
                {
                    id: 'exp1',
                    code: 'A1.1',
                    description: 'Number recognition',
                    strand: 'Number Sense',
                },
                {
                    id: 'exp2',
                    code: 'A1.2',
                    description: 'Counting objects',
                    strand: 'Number Sense',
                },
            ];
            mockPrisma.curriculumExpectation.findMany.mockResolvedValue(mockExpectations);
            mockPrisma.expectationCluster.createMany.mockResolvedValue({ count: 1 });
            mockPrisma.curriculumImport.update.mockResolvedValue({});
            const result = await curriculumImportService.generateClusters(importId);
            expect(result.clustersCreated).toBe(1);
            expect(result.clusters).toHaveLength(1);
            expect(result.clusters[0].clusterName).toBe('Number Operations');
            expect(result.clusters[0].expectationIds).toEqual(['exp1', 'exp2']);
        });
        test('should handle empty expectations', async () => {
            const importId = 'import1';
            mockPrisma.curriculumExpectation.findMany.mockResolvedValue([]);
            const result = await curriculumImportService.generateClusters(importId);
            expect(result.clustersCreated).toBe(0);
            expect(result.clusters).toHaveLength(0);
        });
    });
    describe('getImportProgress', () => {
        test('should return detailed import progress', async () => {
            const importId = 'import1';
            const mockImport = {
                id: importId,
                status: 'PROCESSING',
                totalOutcomes: 100,
                processedOutcomes: 75,
                errorLog: [
                    { line: 10, error: 'Invalid format' },
                    { line: 25, error: 'Missing code' },
                ],
                createdAt: new Date('2024-01-01'),
                updatedAt: new Date('2024-01-02'),
            };
            mockPrisma.curriculumImport.findUnique.mockResolvedValue(mockImport);
            const result = await curriculumImportService.getImportProgress(importId);
            expect(result).toEqual({
                id: importId,
                status: 'PROCESSING',
                progress: 75, // processedOutcomes / totalOutcomes * 100
                totalOutcomes: 100,
                processedOutcomes: 75,
                errorCount: 2,
                errors: mockImport.errorLog,
                createdAt: mockImport.createdAt,
                updatedAt: mockImport.updatedAt,
            });
        });
        test('should handle import not found', async () => {
            const importId = 'nonexistent';
            mockPrisma.curriculumImport.findUnique.mockResolvedValue(null);
            await expect(curriculumImportService.getImportProgress(importId)).rejects.toThrow('Import not found');
        });
    });
    describe('getUserImports', () => {
        test('should return user imports with statistics', async () => {
            const userId = 1;
            const mockImports = [
                {
                    id: 'import1',
                    filename: 'grade1-math.pdf',
                    status: 'COMPLETED',
                    grade: 1,
                    subject: 'Mathematics',
                    totalOutcomes: 50,
                    processedOutcomes: 50,
                    createdAt: new Date('2024-01-01'),
                    curriculumExpectations: [{ id: 'exp1' }, { id: 'exp2' }],
                    clusters: [{ id: 'cluster1' }],
                },
                {
                    id: 'import2',
                    filename: 'grade1-science.pdf',
                    status: 'PROCESSING',
                    grade: 1,
                    subject: 'Science',
                    totalOutcomes: 30,
                    processedOutcomes: 20,
                    createdAt: new Date('2024-01-02'),
                    curriculumExpectations: [{ id: 'exp3' }],
                    clusters: [],
                },
            ];
            mockPrisma.curriculumImport.findMany.mockResolvedValue(mockImports);
            const result = await curriculumImportService.getUserImports(userId);
            expect(result).toHaveLength(2);
            expect(result[0].id).toBe('import1');
            expect(result[0].expectationCount).toBe(2);
            expect(result[0].clusterCount).toBe(1);
            expect(result[1].id).toBe('import2');
            expect(result[1].expectationCount).toBe(1);
            expect(result[1].clusterCount).toBe(0);
        });
    });
    describe('validateImportData', () => {
        test('should validate required fields', () => {
            const validData = {
                filename: 'test.pdf',
                grade: 1,
                subject: 'Mathematics',
            };
            expect(() => curriculumImportService.validateImportData(validData)).not.toThrow();
        });
        test('should reject invalid grade', () => {
            const invalidData = {
                filename: 'test.pdf',
                grade: 15, // Invalid grade
                subject: 'Mathematics',
            };
            expect(() => curriculumImportService.validateImportData(invalidData))
                .toThrow('Grade must be between 1 and 12');
        });
        test('should reject missing filename', () => {
            const invalidData = {
                grade: 1,
                subject: 'Mathematics',
            };
            expect(() => curriculumImportService.validateImportData(invalidData))
                .toThrow('Filename is required');
        });
        test('should reject unsupported file type', () => {
            const invalidData = {
                filename: 'test.txt', // Unsupported extension
                grade: 1,
                subject: 'Mathematics',
            };
            expect(() => curriculumImportService.validateImportData(invalidData))
                .toThrow('Unsupported file type');
        });
    });
    describe('error handling', () => {
        test('should handle database errors during import creation', async () => {
            const userId = 1;
            const importData = {
                filename: 'test.pdf',
                grade: 1,
                subject: 'Mathematics',
            };
            mockPrisma.curriculumImport.create.mockRejectedValue(new Error('Database connection failed'));
            await expect(curriculumImportService.createImport(userId, importData)).rejects.toThrow('Database connection failed');
        });
        test('should handle transaction failures during parsing', async () => {
            const importId = 'import1';
            const rawText = 'A1.1 - Test expectation';
            const mockImport = {
                id: importId,
                grade: 1,
                subject: 'Mathematics',
            };
            mockPrisma.curriculumImport.findUnique.mockResolvedValue(mockImport);
            mockPrisma.$transaction.mockRejectedValue(new Error('Transaction failed'));
            await expect(curriculumImportService.parseTextContent(importId, rawText)).rejects.toThrow('Transaction failed');
        });
        test('should update import status to FAILED on error', async () => {
            const importId = 'import1';
            const errorMessage = 'Processing failed';
            await curriculumImportService.markImportAsFailed(importId, errorMessage);
            expect(mockPrisma.curriculumImport.update).toHaveBeenCalledWith({
                where: { id: importId },
                data: {
                    status: 'FAILED',
                    errorMessage,
                    updatedAt: expect.any(Date),
                },
            });
        });
    });
    describe('performance optimization', () => {
        test('should batch process large datasets', async () => {
            const importId = 'import1';
            const largeText = Array.from({ length: 1000 }, (_, i) => `A${i}.1 - Test expectation ${i}`).join('\n');
            const mockImport = {
                id: importId,
                grade: 1,
                subject: 'Mathematics',
            };
            mockPrisma.curriculumImport.findUnique.mockResolvedValue(mockImport);
            mockPrisma.curriculumImport.update.mockResolvedValue({});
            mockPrisma.$transaction.mockImplementation(async (callback) => {
                return await callback(mockPrisma);
            });
            mockPrisma.curriculumExpectation.createMany.mockResolvedValue({ count: 1000 });
            const result = await curriculumImportService.parseTextContent(importId, largeText);
            expect(result.processedCount).toBe(1000);
            expect(result.expectations).toHaveLength(1000);
            // Should have called createMany to batch insert
            expect(mockPrisma.curriculumExpectation.createMany).toHaveBeenCalled();
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL21pY2hhZWxtY2lzYWFjL0dpdEh1Yi90ZWFjaGluZy1lbmdpbmUyLjAvc2VydmVyL3Rlc3RzL3VuaXQvY3VycmljdWx1bUltcG9ydFNlcnZpY2UudGVzdC50cyIsIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUl6RSxjQUFjO0FBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQ25DLE1BQU0sRUFBRTtRQUNOLGdCQUFnQixFQUFFO1lBQ2hCLE1BQU0sRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ2pCLE1BQU0sRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ2pCLFVBQVUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ3JCLFFBQVEsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1NBQ3BCO1FBQ0QscUJBQXFCLEVBQUU7WUFDckIsVUFBVSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7WUFDckIsUUFBUSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7U0FDcEI7UUFDRCxrQkFBa0IsRUFBRTtZQUNsQixVQUFVLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtTQUN0QjtRQUNELFlBQVksRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0tBQ3hCO0NBQ0YsQ0FBQyxDQUFDLENBQUM7QUFFSix5QkFBeUI7QUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQyxxQ0FBcUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQ3RELGdCQUFnQixFQUFFO1FBQ2hCLGlCQUFpQixFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDL0QsdUJBQXVCLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGlCQUFpQixD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LENBQUMsa0JBQWtCLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxFQUFFO2dCQUM1RCxPQUFPLE1BQU0sUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ3BDLENBQUMsQ0FBQyxDQUFDO1lBQ0gsVUFBVSxDQUFDLHFCQUFxQixDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQVMsQ0FBQyxDQUFDO1lBRXRGLE1BQU0sTUFBTSxHQUFHLE1BQU0sdUJBQXVCLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBRW5GLE1BQU0sQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3pDLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRS9DLGdEQUFnRDtZQUNoRCxNQUFNLENBQUMsVUFBVSxDQUFDLHFCQUFxQixDQUFDLFVBQVUsQ0FBQyxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFDekUsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsbWNpc2FhYy9HaXRIdWIvdGVhY2hpbmctZW5naW5lMi4wL3NlcnZlci90ZXN0cy91bml0L2N1cnJpY3VsdW1JbXBvcnRTZXJ2aWNlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVzY3JpYmUsIHRlc3QsIGV4cGVjdCwgYmVmb3JlRWFjaCwgamVzdCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnO1xuaW1wb3J0IHsgQ3VycmljdWx1bUltcG9ydFNlcnZpY2UgfSBmcm9tICcuLi8uLi9zcmMvc2VydmljZXMvY3VycmljdWx1bUltcG9ydFNlcnZpY2UnO1xuaW1wb3J0IHsgcHJpc21hIH0gZnJvbSAnLi4vLi4vc3JjL3ByaXNtYSc7XG5cbi8vIE1vY2sgUHJpc21hXG5qZXN0Lm1vY2soJy4uLy4uL3NyYy9wcmlzbWEnLCAoKSA9PiAoe1xuICBwcmlzbWE6IHtcbiAgICBjdXJyaWN1bHVtSW1wb3J0OiB7XG4gICAgICBjcmVhdGU6IGplc3QuZm4oKSxcbiAgICAgIHVwZGF0ZTogamVzdC5mbigpLFxuICAgICAgZmluZFVuaXF1ZTogamVzdC5mbigpLFxuICAgICAgZmluZE1hbnk6IGplc3QuZm4oKSxcbiAgICB9LFxuICAgIGN1cnJpY3VsdW1FeHBlY3RhdGlvbjoge1xuICAgICAgY3JlYXRlTWFueTogamVzdC5mbigpLFxuICAgICAgZmluZE1hbnk6IGplc3QuZm4oKSxcbiAgICB9LFxuICAgIGV4cGVjdGF0aW9uQ2x1c3Rlcjoge1xuICAgICAgY3JlYXRlTWFueTogamVzdC5mbigpLFxuICAgIH0sXG4gICAgJHRyYW5zYWN0aW9uOiBqZXN0LmZuKCksXG4gIH0sXG59KSk7XG5cbi8vIE1vY2sgZXh0ZXJuYWwgc2VydmljZXNcbmplc3QubW9jaygnLi4vLi4vc3JjL3NlcnZpY2VzL2VtYmVkZGluZ1NlcnZpY2UnLCAoKSA9PiAoe1xuICBlbWJlZGRpbmdTZXJ2aWNlOiB7XG4gICAgZ2VuZXJhdGVFbWJlZGRpbmc6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShbMC4xLCAwLjIsIDAuM10pLFxuICAgIGdlbmVyYXRlQmF0Y2hFbWJlZGRpbmdzOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoW1swLjEsIDAuMiwgMC4zXSwgWzAuNCwgMC41LCAwLjZdXSksXG4gIH0sXG59KSk7XG5cbmplc3QubW9jaygnLi4vLi4vc3JjL3NlcnZpY2VzL2NsdXN0ZXJpbmdTZXJ2aWNlJywgKCkgPT4gKHtcbiAgY2x1c3RlcmluZ1NlcnZpY2U6IHtcbiAgICBjbHVzdGVyRXhwZWN0YXRpb25zOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoW1xuICAgICAge1xuICAgICAgICBjbHVzdGVyTmFtZTogJ051bWJlciBPcGVyYXRpb25zJyxcbiAgICAgICAgY2x1c3RlclR5cGU6ICdjb25jZXB0JyxcbiAgICAgICAgZXhwZWN0YXRpb25JZHM6IFsnZXhwMScsICdleHAyJ10sXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuODUsXG4gICAgICB9LFxuICAgIF0pLFxuICB9LFxufSkpO1xuXG5jb25zdCBtb2NrUHJpc21hID0gcHJpc21hIGFzIGplc3QuTW9ja2VkPHR5cGVvZiBwcmlzbWE+O1xuXG5kZXNjcmliZSgnQ3VycmljdWx1bUltcG9ydFNlcnZpY2UnLCAoKSA9PiB7XG4gIGxldCBjdXJyaWN1bHVtSW1wb3J0U2VydmljZTogQ3VycmljdWx1bUltcG9ydFNlcnZpY2U7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgY3VycmljdWx1bUltcG9ydFNlcnZpY2UgPSBuZXcgQ3VycmljdWx1bUltcG9ydFNlcnZpY2UoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NyZWF0ZUltcG9ydCcsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgY3JlYXRlIG5ldyBjdXJyaWN1bHVtIGltcG9ydCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IDE7XG4gICAgICBjb25zdCBpbXBvcnREYXRhID0ge1xuICAgICAgICBmaWxlbmFtZTogJ3Rlc3QtY3VycmljdWx1bS5wZGYnLFxuICAgICAgICBvcmlnaW5hbE5hbWU6ICdHcmFkZSAxIE1hdGggQ3VycmljdWx1bS5wZGYnLFxuICAgICAgICBncmFkZTogMSxcbiAgICAgICAgc3ViamVjdDogJ01hdGhlbWF0aWNzJyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tJbXBvcnQgPSB7XG4gICAgICAgIGlkOiAnaW1wb3J0MScsXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgLi4uaW1wb3J0RGF0YSxcbiAgICAgICAgc3RhdHVzOiAnVVBMT0FESU5HJyxcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgfTtcblxuICAgICAgbW9ja1ByaXNtYS5jdXJyaWN1bHVtSW1wb3J0LmNyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrSW1wb3J0IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGN1cnJpY3VsdW1JbXBvcnRTZXJ2aWNlLmNyZWF0ZUltcG9ydCh1c2VySWQsIGltcG9ydERhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tJbXBvcnQpO1xuICAgICAgZXhwZWN0KG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICAuLi5pbXBvcnREYXRhLFxuICAgICAgICAgIHN0YXR1czogJ1VQTE9BRElORycsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3VwZGF0ZUltcG9ydFN0YXR1cycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgdXBkYXRlIGltcG9ydCBzdGF0dXMgYW5kIG1ldGFkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW1wb3J0SWQgPSAnaW1wb3J0MSc7XG4gICAgICBjb25zdCBzdGF0dXMgPSAnUFJPQ0VTU0lORyc7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHsgc3RlcDogJ3BhcnNpbmdfcGRmJyB9O1xuXG4gICAgICBjb25zdCBtb2NrVXBkYXRlZEltcG9ydCA9IHtcbiAgICAgICAgaWQ6IGltcG9ydElkLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICB9O1xuXG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1JbXBvcnQudXBkYXRlLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVcGRhdGVkSW1wb3J0IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGN1cnJpY3VsdW1JbXBvcnRTZXJ2aWNlLnVwZGF0ZUltcG9ydFN0YXR1cyhpbXBvcnRJZCwgc3RhdHVzLCBtZXRhZGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja1VwZGF0ZWRJbXBvcnQpO1xuICAgICAgZXhwZWN0KG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC51cGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgd2hlcmU6IHsgaWQ6IGltcG9ydElkIH0sXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgdXBkYXRlZEF0OiBleHBlY3QuYW55KERhdGUpLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIHByb2Nlc3NpbmcgY29tcGxldGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGltcG9ydElkID0gJ2ltcG9ydDEnO1xuICAgICAgY29uc3Qgc3RhdHVzID0gJ0NPTVBMRVRFRCc7XG5cbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC51cGRhdGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBpZDogaW1wb3J0SWQsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgcHJvY2Vzc2VkQXQ6IGV4cGVjdC5hbnkoRGF0ZSksXG4gICAgICAgIGNvbXBsZXRlZEF0OiBleHBlY3QuYW55KERhdGUpLFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBhd2FpdCBjdXJyaWN1bHVtSW1wb3J0U2VydmljZS51cGRhdGVJbXBvcnRTdGF0dXMoaW1wb3J0SWQsIHN0YXR1cyk7XG5cbiAgICAgIGV4cGVjdChtb2NrUHJpc21hLmN1cnJpY3VsdW1JbXBvcnQudXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIHdoZXJlOiB7IGlkOiBpbXBvcnRJZCB9LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgIHByb2Nlc3NlZEF0OiBleHBlY3QuYW55KERhdGUpLFxuICAgICAgICAgIGNvbXBsZXRlZEF0OiBleHBlY3QuYW55KERhdGUpLFxuICAgICAgICAgIHVwZGF0ZWRBdDogZXhwZWN0LmFueShEYXRlKSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgncGFyc2VUZXh0Q29udGVudCcsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgcGFyc2UgY3VycmljdWx1bSB0ZXh0IGludG8gc3RydWN0dXJlZCBleHBlY3RhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbXBvcnRJZCA9ICdpbXBvcnQxJztcbiAgICAgIGNvbnN0IHJhd1RleHQgPSBgXG4gICAgICAgIEExLjEgLSBTdHVkZW50cyB3aWxsIGRlbW9uc3RyYXRlIHVuZGVyc3RhbmRpbmcgb2YgbnVtYmVycyAxLTEwXG4gICAgICAgIEExLjIgLSBTdHVkZW50cyB3aWxsIGNvdW50IG9iamVjdHMgYWNjdXJhdGVseSB1cCB0byAyMFxuICAgICAgICBCMi4xIC0gU3R1ZGVudHMgd2lsbCBpZGVudGlmeSBhbmQgZXh0ZW5kIHNpbXBsZSBwYXR0ZXJuc1xuICAgICAgYDtcblxuICAgICAgY29uc3QgbW9ja0ltcG9ydCA9IHtcbiAgICAgICAgaWQ6IGltcG9ydElkLFxuICAgICAgICBncmFkZTogMSxcbiAgICAgICAgc3ViamVjdDogJ01hdGhlbWF0aWNzJyxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC5maW5kVW5pcXVlLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tJbXBvcnQgYXMgYW55KTtcbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC51cGRhdGUubW9ja1Jlc29sdmVkVmFsdWUoe30gYXMgYW55KTtcbiAgICAgIG1vY2tQcmlzbWEuJHRyYW5zYWN0aW9uLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNhbGxiYWNrKG1vY2tQcmlzbWEpO1xuICAgICAgfSk7XG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1FeHBlY3RhdGlvbi5jcmVhdGVNYW55Lm1vY2tSZXNvbHZlZFZhbHVlKHsgY291bnQ6IDMgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjdXJyaWN1bHVtSW1wb3J0U2VydmljZS5wYXJzZVRleHRDb250ZW50KGltcG9ydElkLCByYXdUZXh0KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5wcm9jZXNzZWRDb3VudCkudG9CZSgzKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXhwZWN0YXRpb25zKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICBleHBlY3QocmVzdWx0LmV4cGVjdGF0aW9uc1swXS5jb2RlKS50b0JlKCdBMS4xJyk7XG4gICAgICBleHBlY3QocmVzdWx0LmV4cGVjdGF0aW9uc1swXS5kZXNjcmlwdGlvbikudG9CZSgnU3R1ZGVudHMgd2lsbCBkZW1vbnN0cmF0ZSB1bmRlcnN0YW5kaW5nIG9mIG51bWJlcnMgMS0xMCcpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5leHBlY3RhdGlvbnNbMV0uY29kZSkudG9CZSgnQTEuMicpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5leHBlY3RhdGlvbnNbMl0uY29kZSkudG9CZSgnQjIuMScpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBtYWxmb3JtZWQgdGV4dCBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW1wb3J0SWQgPSAnaW1wb3J0MSc7XG4gICAgICBjb25zdCByYXdUZXh0ID0gYFxuICAgICAgICBJbnZhbGlkIGxpbmUgd2l0aG91dCBwcm9wZXIgZm9ybWF0XG4gICAgICAgIEExLjEgLSBWYWxpZCBleHBlY3RhdGlvblxuICAgICAgICBBbm90aGVyIGludmFsaWQgbGluZVxuICAgICAgYDtcblxuICAgICAgY29uc3QgbW9ja0ltcG9ydCA9IHtcbiAgICAgICAgaWQ6IGltcG9ydElkLFxuICAgICAgICBncmFkZTogMSxcbiAgICAgICAgc3ViamVjdDogJ01hdGhlbWF0aWNzJyxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC5maW5kVW5pcXVlLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tJbXBvcnQgYXMgYW55KTtcbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC51cGRhdGUubW9ja1Jlc29sdmVkVmFsdWUoe30gYXMgYW55KTtcbiAgICAgIG1vY2tQcmlzbWEuJHRyYW5zYWN0aW9uLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNhbGxiYWNrKG1vY2tQcmlzbWEpO1xuICAgICAgfSk7XG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1FeHBlY3RhdGlvbi5jcmVhdGVNYW55Lm1vY2tSZXNvbHZlZFZhbHVlKHsgY291bnQ6IDEgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjdXJyaWN1bHVtSW1wb3J0U2VydmljZS5wYXJzZVRleHRDb250ZW50KGltcG9ydElkLCByYXdUZXh0KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5wcm9jZXNzZWRDb3VudCkudG9CZSgxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXhwZWN0YXRpb25zKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QocmVzdWx0LmV4cGVjdGF0aW9uc1swXS5jb2RlKS50b0JlKCdBMS4xJyk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9ycykudG9IYXZlTGVuZ3RoKDIpOyAvLyBUd28gaW52YWxpZCBsaW5lc1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgncHJvY2Vzc0NTVkNvbnRlbnQnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHBhcnNlIENTViBjdXJyaWN1bHVtIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbXBvcnRJZCA9ICdpbXBvcnQxJztcbiAgICAgIGNvbnN0IGNzdkNvbnRlbnQgPSBgY29kZSxkZXNjcmlwdGlvbixzdHJhbmQsc3Vic3RyYW5kLGdyYWRlLHN1YmplY3RcbkExLjEsXCJTdHVkZW50cyB3aWxsIGRlbW9uc3RyYXRlIHVuZGVyc3RhbmRpbmcgb2YgbnVtYmVycyAxLTEwXCIsXCJOdW1iZXIgU2Vuc2VcIixcIkNvdW50aW5nXCIsMSxcIk1hdGhlbWF0aWNzXCJcbkExLjIsXCJTdHVkZW50cyB3aWxsIGNvdW50IG9iamVjdHMgYWNjdXJhdGVseSB1cCB0byAyMFwiLFwiTnVtYmVyIFNlbnNlXCIsXCJDb3VudGluZ1wiLDEsXCJNYXRoZW1hdGljc1wiXG5CMi4xLFwiU3R1ZGVudHMgd2lsbCBpZGVudGlmeSBhbmQgZXh0ZW5kIHNpbXBsZSBwYXR0ZXJuc1wiLFwiUGF0dGVybnNcIixcIlNpbXBsZSBQYXR0ZXJuc1wiLDEsXCJNYXRoZW1hdGljc1wiYDtcblxuICAgICAgY29uc3QgbW9ja0ltcG9ydCA9IHtcbiAgICAgICAgaWQ6IGltcG9ydElkLFxuICAgICAgICBncmFkZTogMSxcbiAgICAgICAgc3ViamVjdDogJ01hdGhlbWF0aWNzJyxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC5maW5kVW5pcXVlLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tJbXBvcnQgYXMgYW55KTtcbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC51cGRhdGUubW9ja1Jlc29sdmVkVmFsdWUoe30gYXMgYW55KTtcbiAgICAgIG1vY2tQcmlzbWEuJHRyYW5zYWN0aW9uLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNhbGxiYWNrKG1vY2tQcmlzbWEpO1xuICAgICAgfSk7XG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1FeHBlY3RhdGlvbi5jcmVhdGVNYW55Lm1vY2tSZXNvbHZlZFZhbHVlKHsgY291bnQ6IDMgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjdXJyaWN1bHVtSW1wb3J0U2VydmljZS5wcm9jZXNzQ1NWQ29udGVudChpbXBvcnRJZCwgY3N2Q29udGVudCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQucHJvY2Vzc2VkQ291bnQpLnRvQmUoMyk7XG4gICAgICBleHBlY3QocmVzdWx0LmV4cGVjdGF0aW9ucykudG9IYXZlTGVuZ3RoKDMpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5leHBlY3RhdGlvbnNbMF0uc3RyYW5kKS50b0JlKCdOdW1iZXIgU2Vuc2UnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXhwZWN0YXRpb25zWzBdLnN1YnN0cmFuZCkudG9CZSgnQ291bnRpbmcnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXhwZWN0YXRpb25zWzJdLnN0cmFuZCkudG9CZSgnUGF0dGVybnMnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbWlzc2luZyByZXF1aXJlZCBjb2x1bW5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW1wb3J0SWQgPSAnaW1wb3J0MSc7XG4gICAgICBjb25zdCBjc3ZDb250ZW50ID0gYGRlc2NyaXB0aW9uLHN0cmFuZFxuXCJTdHVkZW50cyB3aWxsIGRlbW9uc3RyYXRlIHVuZGVyc3RhbmRpbmcgb2YgbnVtYmVycyAxLTEwXCIsXCJOdW1iZXIgU2Vuc2VcImA7XG5cbiAgICAgIGNvbnN0IG1vY2tJbXBvcnQgPSB7XG4gICAgICAgIGlkOiBpbXBvcnRJZCxcbiAgICAgICAgZ3JhZGU6IDEsXG4gICAgICAgIHN1YmplY3Q6ICdNYXRoZW1hdGljcycsXG4gICAgICB9O1xuXG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1JbXBvcnQuZmluZFVuaXF1ZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrSW1wb3J0IGFzIGFueSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgY3VycmljdWx1bUltcG9ydFNlcnZpY2UucHJvY2Vzc0NTVkNvbnRlbnQoaW1wb3J0SWQsIGNzdkNvbnRlbnQpXG4gICAgICApLnJlamVjdHMudG9UaHJvdygnTWlzc2luZyByZXF1aXJlZCBjb2x1bW5zJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZW5lcmF0ZUNsdXN0ZXJzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBjcmVhdGUgZXhwZWN0YXRpb24gY2x1c3RlcnMgdXNpbmcgQUknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbXBvcnRJZCA9ICdpbXBvcnQxJztcblxuICAgICAgY29uc3QgbW9ja0V4cGVjdGF0aW9ucyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAnZXhwMScsXG4gICAgICAgICAgY29kZTogJ0ExLjEnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTnVtYmVyIHJlY29nbml0aW9uJyxcbiAgICAgICAgICBzdHJhbmQ6ICdOdW1iZXIgU2Vuc2UnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdleHAyJyxcbiAgICAgICAgICBjb2RlOiAnQTEuMicsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdDb3VudGluZyBvYmplY3RzJyxcbiAgICAgICAgICBzdHJhbmQ6ICdOdW1iZXIgU2Vuc2UnLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgbW9ja1ByaXNtYS5jdXJyaWN1bHVtRXhwZWN0YXRpb24uZmluZE1hbnkubW9ja1Jlc29sdmVkVmFsdWUobW9ja0V4cGVjdGF0aW9ucyBhcyBhbnkpO1xuICAgICAgbW9ja1ByaXNtYS5leHBlY3RhdGlvbkNsdXN0ZXIuY3JlYXRlTWFueS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGNvdW50OiAxIH0gYXMgYW55KTtcbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC51cGRhdGUubW9ja1Jlc29sdmVkVmFsdWUoe30gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3VycmljdWx1bUltcG9ydFNlcnZpY2UuZ2VuZXJhdGVDbHVzdGVycyhpbXBvcnRJZCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY2x1c3RlcnNDcmVhdGVkKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jbHVzdGVycykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jbHVzdGVyc1swXS5jbHVzdGVyTmFtZSkudG9CZSgnTnVtYmVyIE9wZXJhdGlvbnMnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY2x1c3RlcnNbMF0uZXhwZWN0YXRpb25JZHMpLnRvRXF1YWwoWydleHAxJywgJ2V4cDInXSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGVtcHR5IGV4cGVjdGF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGltcG9ydElkID0gJ2ltcG9ydDEnO1xuXG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1FeHBlY3RhdGlvbi5maW5kTWFueS5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGN1cnJpY3VsdW1JbXBvcnRTZXJ2aWNlLmdlbmVyYXRlQ2x1c3RlcnMoaW1wb3J0SWQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmNsdXN0ZXJzQ3JlYXRlZCkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY2x1c3RlcnMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldEltcG9ydFByb2dyZXNzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gZGV0YWlsZWQgaW1wb3J0IHByb2dyZXNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW1wb3J0SWQgPSAnaW1wb3J0MSc7XG5cbiAgICAgIGNvbnN0IG1vY2tJbXBvcnQgPSB7XG4gICAgICAgIGlkOiBpbXBvcnRJZCxcbiAgICAgICAgc3RhdHVzOiAnUFJPQ0VTU0lORycsXG4gICAgICAgIHRvdGFsT3V0Y29tZXM6IDEwMCxcbiAgICAgICAgcHJvY2Vzc2VkT3V0Y29tZXM6IDc1LFxuICAgICAgICBlcnJvckxvZzogW1xuICAgICAgICAgIHsgbGluZTogMTAsIGVycm9yOiAnSW52YWxpZCBmb3JtYXQnIH0sXG4gICAgICAgICAgeyBsaW5lOiAyNSwgZXJyb3I6ICdNaXNzaW5nIGNvZGUnIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoJzIwMjQtMDEtMDEnKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgnMjAyNC0wMS0wMicpLFxuICAgICAgfTtcblxuICAgICAgbW9ja1ByaXNtYS5jdXJyaWN1bHVtSW1wb3J0LmZpbmRVbmlxdWUubW9ja1Jlc29sdmVkVmFsdWUobW9ja0ltcG9ydCBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjdXJyaWN1bHVtSW1wb3J0U2VydmljZS5nZXRJbXBvcnRQcm9ncmVzcyhpbXBvcnRJZCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICBpZDogaW1wb3J0SWQsXG4gICAgICAgIHN0YXR1czogJ1BST0NFU1NJTkcnLFxuICAgICAgICBwcm9ncmVzczogNzUsIC8vIHByb2Nlc3NlZE91dGNvbWVzIC8gdG90YWxPdXRjb21lcyAqIDEwMFxuICAgICAgICB0b3RhbE91dGNvbWVzOiAxMDAsXG4gICAgICAgIHByb2Nlc3NlZE91dGNvbWVzOiA3NSxcbiAgICAgICAgZXJyb3JDb3VudDogMixcbiAgICAgICAgZXJyb3JzOiBtb2NrSW1wb3J0LmVycm9yTG9nLFxuICAgICAgICBjcmVhdGVkQXQ6IG1vY2tJbXBvcnQuY3JlYXRlZEF0LFxuICAgICAgICB1cGRhdGVkQXQ6IG1vY2tJbXBvcnQudXBkYXRlZEF0LFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGltcG9ydCBub3QgZm91bmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbXBvcnRJZCA9ICdub25leGlzdGVudCc7XG5cbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUltcG9ydC5maW5kVW5pcXVlLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIGN1cnJpY3VsdW1JbXBvcnRTZXJ2aWNlLmdldEltcG9ydFByb2dyZXNzKGltcG9ydElkKVxuICAgICAgKS5yZWplY3RzLnRvVGhyb3coJ0ltcG9ydCBub3QgZm91bmQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldFVzZXJJbXBvcnRzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdXNlciBpbXBvcnRzIHdpdGggc3RhdGlzdGljcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IDE7XG5cbiAgICAgIGNvbnN0IG1vY2tJbXBvcnRzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdpbXBvcnQxJyxcbiAgICAgICAgICBmaWxlbmFtZTogJ2dyYWRlMS1tYXRoLnBkZicsXG4gICAgICAgICAgc3RhdHVzOiAnQ09NUExFVEVEJyxcbiAgICAgICAgICBncmFkZTogMSxcbiAgICAgICAgICBzdWJqZWN0OiAnTWF0aGVtYXRpY3MnLFxuICAgICAgICAgIHRvdGFsT3V0Y29tZXM6IDUwLFxuICAgICAgICAgIHByb2Nlc3NlZE91dGNvbWVzOiA1MCxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCcyMDI0LTAxLTAxJyksXG4gICAgICAgICAgY3VycmljdWx1bUV4cGVjdGF0aW9uczogW3sgaWQ6ICdleHAxJyB9LCB7IGlkOiAnZXhwMicgfV0sXG4gICAgICAgICAgY2x1c3RlcnM6IFt7IGlkOiAnY2x1c3RlcjEnIH1dLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdpbXBvcnQyJyxcbiAgICAgICAgICBmaWxlbmFtZTogJ2dyYWRlMS1zY2llbmNlLnBkZicsXG4gICAgICAgICAgc3RhdHVzOiAnUFJPQ0VTU0lORycsXG4gICAgICAgICAgZ3JhZGU6IDEsXG4gICAgICAgICAgc3ViamVjdDogJ1NjaWVuY2UnLFxuICAgICAgICAgIHRvdGFsT3V0Y29tZXM6IDMwLFxuICAgICAgICAgIHByb2Nlc3NlZE91dGNvbWVzOiAyMCxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCcyMDI0LTAxLTAyJyksXG4gICAgICAgICAgY3VycmljdWx1bUV4cGVjdGF0aW9uczogW3sgaWQ6ICdleHAzJyB9XSxcbiAgICAgICAgICBjbHVzdGVyczogW10sXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1JbXBvcnQuZmluZE1hbnkubW9ja1Jlc29sdmVkVmFsdWUobW9ja0ltcG9ydHMgYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3VycmljdWx1bUltcG9ydFNlcnZpY2UuZ2V0VXNlckltcG9ydHModXNlcklkKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdFswXS5pZCkudG9CZSgnaW1wb3J0MScpO1xuICAgICAgZXhwZWN0KHJlc3VsdFswXS5leHBlY3RhdGlvbkNvdW50KS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdFswXS5jbHVzdGVyQ291bnQpLnRvQmUoMSk7XG4gICAgICBleHBlY3QocmVzdWx0WzFdLmlkKS50b0JlKCdpbXBvcnQyJyk7XG4gICAgICBleHBlY3QocmVzdWx0WzFdLmV4cGVjdGF0aW9uQ291bnQpLnRvQmUoMSk7XG4gICAgICBleHBlY3QocmVzdWx0WzFdLmNsdXN0ZXJDb3VudCkudG9CZSgwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3ZhbGlkYXRlSW1wb3J0RGF0YScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgdmFsaWRhdGUgcmVxdWlyZWQgZmllbGRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWREYXRhID0ge1xuICAgICAgICBmaWxlbmFtZTogJ3Rlc3QucGRmJyxcbiAgICAgICAgZ3JhZGU6IDEsXG4gICAgICAgIHN1YmplY3Q6ICdNYXRoZW1hdGljcycsXG4gICAgICB9O1xuXG4gICAgICBleHBlY3QoKCkgPT4gY3VycmljdWx1bUltcG9ydFNlcnZpY2UudmFsaWRhdGVJbXBvcnREYXRhKHZhbGlkRGF0YSkpLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgZ3JhZGUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkRGF0YSA9IHtcbiAgICAgICAgZmlsZW5hbWU6ICd0ZXN0LnBkZicsXG4gICAgICAgIGdyYWRlOiAxNSwgLy8gSW52YWxpZCBncmFkZVxuICAgICAgICBzdWJqZWN0OiAnTWF0aGVtYXRpY3MnLFxuICAgICAgfTtcblxuICAgICAgZXhwZWN0KCgpID0+IGN1cnJpY3VsdW1JbXBvcnRTZXJ2aWNlLnZhbGlkYXRlSW1wb3J0RGF0YShpbnZhbGlkRGF0YSkpXG4gICAgICAgIC50b1Rocm93KCdHcmFkZSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgMTInKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZWplY3QgbWlzc2luZyBmaWxlbmFtZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWREYXRhID0ge1xuICAgICAgICBncmFkZTogMSxcbiAgICAgICAgc3ViamVjdDogJ01hdGhlbWF0aWNzJyxcbiAgICAgIH07XG5cbiAgICAgIGV4cGVjdCgoKSA9PiBjdXJyaWN1bHVtSW1wb3J0U2VydmljZS52YWxpZGF0ZUltcG9ydERhdGEoaW52YWxpZERhdGEpKVxuICAgICAgICAudG9UaHJvdygnRmlsZW5hbWUgaXMgcmVxdWlyZWQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZWplY3QgdW5zdXBwb3J0ZWQgZmlsZSB0eXBlJywgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZERhdGEgPSB7XG4gICAgICAgIGZpbGVuYW1lOiAndGVzdC50eHQnLCAvLyBVbnN1cHBvcnRlZCBleHRlbnNpb25cbiAgICAgICAgZ3JhZGU6IDEsXG4gICAgICAgIHN1YmplY3Q6ICdNYXRoZW1hdGljcycsXG4gICAgICB9O1xuXG4gICAgICBleHBlY3QoKCkgPT4gY3VycmljdWx1bUltcG9ydFNlcnZpY2UudmFsaWRhdGVJbXBvcnREYXRhKGludmFsaWREYXRhKSlcbiAgICAgICAgLnRvVGhyb3coJ1Vuc3VwcG9ydGVkIGZpbGUgdHlwZScpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZXJyb3IgaGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBlcnJvcnMgZHVyaW5nIGltcG9ydCBjcmVhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IDE7XG4gICAgICBjb25zdCBpbXBvcnREYXRhID0ge1xuICAgICAgICBmaWxlbmFtZTogJ3Rlc3QucGRmJyxcbiAgICAgICAgZ3JhZGU6IDEsXG4gICAgICAgIHN1YmplY3Q6ICdNYXRoZW1hdGljcycsXG4gICAgICB9O1xuXG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1JbXBvcnQuY3JlYXRlLm1vY2tSZWplY3RlZFZhbHVlKFxuICAgICAgICBuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJylcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgY3VycmljdWx1bUltcG9ydFNlcnZpY2UuY3JlYXRlSW1wb3J0KHVzZXJJZCwgaW1wb3J0RGF0YSlcbiAgICAgICkucmVqZWN0cy50b1Rocm93KCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSB0cmFuc2FjdGlvbiBmYWlsdXJlcyBkdXJpbmcgcGFyc2luZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGltcG9ydElkID0gJ2ltcG9ydDEnO1xuICAgICAgY29uc3QgcmF3VGV4dCA9ICdBMS4xIC0gVGVzdCBleHBlY3RhdGlvbic7XG5cbiAgICAgIGNvbnN0IG1vY2tJbXBvcnQgPSB7XG4gICAgICAgIGlkOiBpbXBvcnRJZCxcbiAgICAgICAgZ3JhZGU6IDEsXG4gICAgICAgIHN1YmplY3Q6ICdNYXRoZW1hdGljcycsXG4gICAgICB9O1xuXG4gICAgICBtb2NrUHJpc21hLmN1cnJpY3VsdW1JbXBvcnQuZmluZFVuaXF1ZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrSW1wb3J0IGFzIGFueSk7XG4gICAgICBtb2NrUHJpc21hLiR0cmFuc2FjdGlvbi5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGZhaWxlZCcpKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBjdXJyaWN1bHVtSW1wb3J0U2VydmljZS5wYXJzZVRleHRDb250ZW50KGltcG9ydElkLCByYXdUZXh0KVxuICAgICAgKS5yZWplY3RzLnRvVGhyb3coJ1RyYW5zYWN0aW9uIGZhaWxlZCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHVwZGF0ZSBpbXBvcnQgc3RhdHVzIHRvIEZBSUxFRCBvbiBlcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGltcG9ydElkID0gJ2ltcG9ydDEnO1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ1Byb2Nlc3NpbmcgZmFpbGVkJztcblxuICAgICAgYXdhaXQgY3VycmljdWx1bUltcG9ydFNlcnZpY2UubWFya0ltcG9ydEFzRmFpbGVkKGltcG9ydElkLCBlcnJvck1lc3NhZ2UpO1xuXG4gICAgICBleHBlY3QobW9ja1ByaXNtYS5jdXJyaWN1bHVtSW1wb3J0LnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB3aGVyZTogeyBpZDogaW1wb3J0SWQgfSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHN0YXR1czogJ0ZBSUxFRCcsXG4gICAgICAgICAgZXJyb3JNZXNzYWdlLFxuICAgICAgICAgIHVwZGF0ZWRBdDogZXhwZWN0LmFueShEYXRlKSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgncGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBiYXRjaCBwcm9jZXNzIGxhcmdlIGRhdGFzZXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW1wb3J0SWQgPSAnaW1wb3J0MSc7XG4gICAgICBjb25zdCBsYXJnZVRleHQgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAwIH0sIChfLCBpKSA9PiBcbiAgICAgICAgYEEke2l9LjEgLSBUZXN0IGV4cGVjdGF0aW9uICR7aX1gXG4gICAgICApLmpvaW4oJ1xcbicpO1xuXG4gICAgICBjb25zdCBtb2NrSW1wb3J0ID0ge1xuICAgICAgICBpZDogaW1wb3J0SWQsXG4gICAgICAgIGdyYWRlOiAxLFxuICAgICAgICBzdWJqZWN0OiAnTWF0aGVtYXRpY3MnLFxuICAgICAgfTtcblxuICAgICAgbW9ja1ByaXNtYS5jdXJyaWN1bHVtSW1wb3J0LmZpbmRVbmlxdWUubW9ja1Jlc29sdmVkVmFsdWUobW9ja0ltcG9ydCBhcyBhbnkpO1xuICAgICAgbW9ja1ByaXNtYS5jdXJyaWN1bHVtSW1wb3J0LnVwZGF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7fSBhcyBhbnkpO1xuICAgICAgbW9ja1ByaXNtYS4kdHJhbnNhY3Rpb24ubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jIChjYWxsYmFjaykgPT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgY2FsbGJhY2sobW9ja1ByaXNtYSk7XG4gICAgICB9KTtcbiAgICAgIG1vY2tQcmlzbWEuY3VycmljdWx1bUV4cGVjdGF0aW9uLmNyZWF0ZU1hbnkubW9ja1Jlc29sdmVkVmFsdWUoeyBjb3VudDogMTAwMCB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGN1cnJpY3VsdW1JbXBvcnRTZXJ2aWNlLnBhcnNlVGV4dENvbnRlbnQoaW1wb3J0SWQsIGxhcmdlVGV4dCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQucHJvY2Vzc2VkQ291bnQpLnRvQmUoMTAwMCk7XG4gICAgICBleHBlY3QocmVzdWx0LmV4cGVjdGF0aW9ucykudG9IYXZlTGVuZ3RoKDEwMDApO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGF2ZSBjYWxsZWQgY3JlYXRlTWFueSB0byBiYXRjaCBpbnNlcnRcbiAgICAgIGV4cGVjdChtb2NrUHJpc21hLmN1cnJpY3VsdW1FeHBlY3RhdGlvbi5jcmVhdGVNYW55KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sInZlcnNpb24iOjN9