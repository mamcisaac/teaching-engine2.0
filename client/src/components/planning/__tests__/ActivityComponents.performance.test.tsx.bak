import React from 'react';
import { render, screen, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { vi, describe, it, expect, beforeEach, afterEach, type Mock } from 'vitest';
import { ActivitySuggestions } from '../../ActivitySuggestions';
import { ActivityLibrary } from '../../ActivityLibrary';

/**
 * Performance Tests for Activity Components
 * 
 * These tests ensure components perform well under various conditions:
 * 1. Large datasets
 * 2. Rapid state changes
 * 3. Memory leaks
 * 4. Render performance
 */

// Mock the toast hook
vi.mock('../../ui/use-toast', () => ({
  useToast: () => ({
    toast: vi.fn(),
  }),
}));

// Mock fetch with controllable responses
global.fetch = vi.fn();

describe.skip('Activity Components Performance Tests', () => {
  let queryClient: QueryClient;
  let performanceMarks: Array<{ name: string; timestamp: number }> = [];

  beforeEach(() => {
    queryClient = new QueryClient({
      defaultOptions: {
        queries: { 
          retry: false,
          refetchOnWindowFocus: false,
        },
      },
    });
    localStorage.setItem('token', 'performance-test-token');
    performanceMarks = [];
    
    // Clear all mocks
    vi.clearAllMocks();
  });

  afterEach(() => {
    localStorage.clear();
    queryClient.clear();
  });

  const wrapper = ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );

  // Helper to mark performance points
  const markPerformance = (name: string) => {
    performanceMarks.push({ name, timestamp: performance.now() });
  };

  // Helper to generate large dataset
  const generateLargeActivityDataset = (count: number) => {
    return Array.from({ length: count }, (_, i) => ({
      id: i + 1,
      titleFr: `Activité ${i + 1}`,
      titleEn: `Activity ${i + 1}`,
      descriptionFr: `Description française pour l'activité ${i + 1}`,
      descriptionEn: `English description for activity ${i + 1}`,
      domain: ['reading', 'writing', 'oral', 'math', 'science'][i % 5],
      subject: ['francais', 'english', 'mathematics', 'science'][i % 4],
      outcomeIds: [`FR${Math.floor(i / 10) + 1}.${(i % 10) + 1}`],
      groupType: ['Whole class', 'Small group', 'Individual'][i % 3],
      prepTimeMin: (i % 60) + 10,
      materialsFr: `Matériaux pour l'activité ${i + 1}`,
      materialsEn: `Materials for activity ${i + 1}`,
      relevanceScore: Math.random(),
      createdAt: new Date(Date.now() - i * 24 * 60 * 60 * 1000).toISOString(),
      updatedAt: new Date(Date.now() - i * 12 * 60 * 60 * 1000).toISOString(),
    }));
  };

  describe('ActivitySuggestions Performance', () => {
    it('should render large dataset of suggestions efficiently', async () => {
      const largeDataset = generateLargeActivityDataset(100);
      
      (global.fetch as Mock<typeof fetch>).mockResolvedValueOnce({
        ok: true,
        json: async () => largeDataset,
      } as Response);

      markPerformance('render-start');
      
      render(
        <ActivitySuggestions 
          outcomeIds={['FR4.1', 'FR4.2', 'FR4.3']}
          
        />, 
        { wrapper }
      );

      markPerformance('render-complete');

      // Wait for data to load
      await waitFor(
        () => {
          const loadingSkeletons = screen.queryAllByTestId('loading-skeleton');
          expect(loadingSkeletons).toHaveLength(0);
        },
        { timeout: 15000 }
      );

      markPerformance('data-loaded');

      // Should render all activities efficiently
      const addButtons = screen.getAllByText('Add');
      expect(addButtons.length).toBeGreaterThan(0);
      
      markPerformance('ui-ready');

      // Calculate performance metrics
      const renderTime = performanceMarks.find(m => m.name === 'render-complete')!.timestamp - 
                        performanceMarks.find(m => m.name === 'render-start')!.timestamp;
      
      const loadTime = performanceMarks.find(m => m.name === 'data-loaded')!.timestamp - 
                      performanceMarks.find(m => m.name === 'render-complete')!.timestamp;

      // Performance assertions
      expect(renderTime).toBeLessThan(100); // Should render in under 100ms
      expect(loadTime).toBeLessThan(5000); // Should load data in under 5s

      console.log('ActivitySuggestions Performance Metrics:', {
        renderTime: `${renderTime.toFixed(2)}ms`,
        loadTime: `${loadTime.toFixed(2)}ms`,
        itemCount: largeDataset.length,
        throughput: `${(largeDataset.length / loadTime * 1000).toFixed(2)} items/second`,
      });
    });

    it('should handle rapid filter changes without performance degradation', async () => {
      const dataset = generateLargeActivityDataset(50);
      
      // Mock different responses for different filters
      (global.fetch as Mock<typeof fetch>)
        .mockResolvedValueOnce({
          ok: true,
          json: async () => dataset,
        } as Response)
        .mockResolvedValueOnce({
          ok: true,
          json: async () => dataset.filter(a => a.domain === 'reading'),
        } as Response)
        .mockResolvedValueOnce({
          ok: true,
          json: async () => dataset.filter(a => a.subject === 'francais'),
        } as Response);

      const { rerender } = render(
        <ActivitySuggestions 
          outcomeIds={['FR4.1']}
          
        />, 
        { wrapper }
      );

      // Wait for initial load
      await waitFor(() => {
        const loadingSkeletons = screen.queryAllByTestId('loading-skeleton');
        expect(loadingSkeletons).toHaveLength(0);
      });

      markPerformance('rapid-changes-start');

      // Simulate rapid filter changes
      rerender(
        <ActivitySuggestions 
          outcomeIds={['FR4.1']}
          domain="reading"
          
        />
      );

      rerender(
        <ActivitySuggestions 
          outcomeIds={['FR4.1']}
          domain="reading"
          subject="francais"
          
        />
      );

      markPerformance('rapid-changes-end');

      // Wait for final state
      await waitFor(() => {
        const loadingSkeletons = screen.queryAllByTestId('loading-skeleton');
        expect(loadingSkeletons).toHaveLength(0);
      });

      const rapidChangeTime = performanceMarks.find(m => m.name === 'rapid-changes-end')!.timestamp - 
                             performanceMarks.find(m => m.name === 'rapid-changes-start')!.timestamp;

      expect(rapidChangeTime).toBeLessThan(200); // Should handle rapid changes in under 200ms

      console.log('Rapid filter changes time:', `${rapidChangeTime.toFixed(2)}ms`);
    });

    it('should not cause memory leaks with frequent re-renders', async () => {
      const dataset = generateLargeActivityDataset(20);
      
      (global.fetch as Mock<typeof fetch>).mockResolvedValue({
        ok: true,
        json: async () => dataset,
      } as Response);

      const { rerender, unmount } = render(
        <ActivitySuggestions 
          outcomeIds={['FR4.1']}
          
        />, 
        { wrapper }
      );

      // Simulate many re-renders
      for (let i = 0; i < 20; i++) {
        rerender(
          <ActivitySuggestions 
            outcomeIds={[`FR4.${i + 1}`]}
            language={i % 2 === 0 ? 'en' : 'fr'}
          />
        );
      }

      // Wait for final render
      await waitFor(() => {
        const loadingSkeletons = screen.queryAllByTestId('loading-skeleton');
        expect(loadingSkeletons).toHaveLength(0);
      });

      // Clean up
      unmount();

      // Memory should be cleaned up
      // Note: Actual memory leak detection would require browser dev tools
      // This test verifies that the component can handle many re-renders
      expect(true).toBe(true);
    });
  });

  describe('ActivityLibrary Performance', () => {
    it('should efficiently render large activity library', async () => {
      const largeLibrary = generateLargeActivityDataset(200);
      
      (global.fetch as Mock<typeof fetch>).mockResolvedValueOnce({
        ok: true,
        json: async () => largeLibrary,
      } as Response);

      markPerformance('library-render-start');
      
      render(
        <ActivityLibrary 
          
          
        />, 
        { wrapper }
      );

      markPerformance('library-render-complete');

      // Wait for data to load
      await waitFor(
        () => {
          expect(screen.getByText(/\d+ activities found/)).toBeInTheDocument();
        },
        { timeout: 15000 }
      );

      markPerformance('library-data-loaded');

      const renderTime = performanceMarks.find(m => m.name === 'library-render-complete')!.timestamp - 
                        performanceMarks.find(m => m.name === 'library-render-start')!.timestamp;
      
      const loadTime = performanceMarks.find(m => m.name === 'library-data-loaded')!.timestamp - 
                      performanceMarks.find(m => m.name === 'library-render-complete')!.timestamp;

      expect(renderTime).toBeLessThan(150); // Should render in under 150ms
      expect(loadTime).toBeLessThan(8000); // Should load large dataset in under 8s

      console.log('ActivityLibrary Performance Metrics:', {
        renderTime: `${renderTime.toFixed(2)}ms`,
        loadTime: `${loadTime.toFixed(2)}ms`,
        itemCount: largeLibrary.length,
        throughput: `${(largeLibrary.length / loadTime * 1000).toFixed(2)} items/second`,
      });
    });

    it('should handle view mode switching efficiently', async () => {
      const dataset = generateLargeActivityDataset(50);
      
      (global.fetch as Mock<typeof fetch>).mockResolvedValue({
        ok: true,
        json: async () => dataset,
      } as Response);

      const { rerender } = render(
        <ActivityLibrary 
          
          
        />, 
        { wrapper }
      );

      // Wait for initial load
      await waitFor(() => {
        expect(screen.getByText(/\d+ activities found/)).toBeInTheDocument();
      });

      markPerformance('view-switch-start');

      // Switch to list view
      rerender(
        <ActivityLibrary 
          
          
        />
      );

      // Switch back to grid
      rerender(
        <ActivityLibrary 
          
          
        />
      );

      markPerformance('view-switch-end');

      const switchTime = performanceMarks.find(m => m.name === 'view-switch-end')!.timestamp - 
                        performanceMarks.find(m => m.name === 'view-switch-start')!.timestamp;

      expect(switchTime).toBeLessThan(100); // View switching should be fast

      console.log('View switching time:', `${switchTime.toFixed(2)}ms`);
    });

    it('should handle search and filtering without blocking UI', async () => {
      const largeDataset = generateLargeActivityDataset(100);
      
      (global.fetch as Mock<typeof fetch>)
        .mockResolvedValueOnce({
          ok: true,
          json: async () => largeDataset,
        } as Response)
        .mockResolvedValueOnce({
          ok: true,
          json: async () => largeDataset.filter(a => a.titleEn.includes('1')),
        } as Response);

      const { rerender } = render(
        <ActivityLibrary />, 
        { wrapper }
      );

      // Wait for initial load
      await waitFor(() => {
        expect(screen.getByText(/\d+ activities found/)).toBeInTheDocument();
      });

      markPerformance('search-start');

      // Simulate search with re-render (in real app this would be user typing)
      rerender(<ActivityLibrary />);

      markPerformance('search-end');

      // Wait for search results
      await waitFor(() => {
        expect(screen.getByText(/\d+ activities found/)).toBeInTheDocument();
      });

      const searchTime = performanceMarks.find(m => m.name === 'search-end')!.timestamp - 
                        performanceMarks.find(m => m.name === 'search-start')!.timestamp;

      expect(searchTime).toBeLessThan(50); // Search should not block UI

      console.log('Search response time:', `${searchTime.toFixed(2)}ms`);
    });
  });

  describe('Component Integration Performance', () => {
    it('should handle multiple components rendering simultaneously', async () => {
      const suggestionsData = generateLargeActivityDataset(30);
      const libraryData = generateLargeActivityDataset(50);
      
      (global.fetch as Mock<typeof fetch>)
        .mockResolvedValueOnce({
          ok: true,
          json: async () => suggestionsData,
        } as Response)
        .mockResolvedValueOnce({
          ok: true,
          json: async () => libraryData,
        } as Response);

      markPerformance('multi-component-start');

      // Render both components simultaneously
      const SuggestionsComponent = (
        <ActivitySuggestions 
          outcomeIds={['FR4.1']}
          
        />
      );

      const LibraryComponent = (
        <ActivityLibrary 
          
          
        />
      );

      const { container } = render(
        <QueryClientProvider client={queryClient}>
          <div>
            {SuggestionsComponent}
            {LibraryComponent}
          </div>
        </QueryClientProvider>
      );

      markPerformance('multi-component-rendered');

      // Wait for both to load
      await waitFor(() => {
        const hasActivitySuggestions = screen.queryByText('Activity Suggestions');
        const hasActivityLibrary = screen.queryByText('Activity Library');
        const noLoadingSkeletons = screen.queryAllByTestId('loading-skeleton').length === 0;
        
        return hasActivitySuggestions && hasActivityLibrary && noLoadingSkeletons;
      }, { timeout: 20000 });

      markPerformance('multi-component-loaded');

      const renderTime = performanceMarks.find(m => m.name === 'multi-component-rendered')!.timestamp - 
                        performanceMarks.find(m => m.name === 'multi-component-start')!.timestamp;
      
      const loadTime = performanceMarks.find(m => m.name === 'multi-component-loaded')!.timestamp - 
                      performanceMarks.find(m => m.name === 'multi-component-rendered')!.timestamp;

      expect(renderTime).toBeLessThan(200); // Should render both in under 200ms
      expect(loadTime).toBeLessThan(15000); // Should load both in under 15s

      console.log('Multi-component Performance:', {
        renderTime: `${renderTime.toFixed(2)}ms`,
        loadTime: `${loadTime.toFixed(2)}ms`,
        totalItems: suggestionsData.length + libraryData.length,
      });
    });
  });

  describe('Error Handling Performance', () => {
    it('should handle API errors without performance degradation', async () => {
      // Mock API errors
      (global.fetch as Mock<typeof fetch>).mockRejectedValue(
        new Error('Network error')
      );

      markPerformance('error-handling-start');

      render(
        <ActivitySuggestions 
          outcomeIds={['FR4.1']}
          
        />, 
        { wrapper }
      );

      // Wait for error state
      await waitFor(() => {
        expect(screen.getByText(/Unable to load/)).toBeInTheDocument();
      }, { timeout: 10000 });

      markPerformance('error-handling-complete');

      const errorHandlingTime = performanceMarks.find(m => m.name === 'error-handling-complete')!.timestamp - 
                               performanceMarks.find(m => m.name === 'error-handling-start')!.timestamp;

      expect(errorHandlingTime).toBeLessThan(5000); // Should handle errors quickly

      console.log('Error handling time:', `${errorHandlingTime.toFixed(2)}ms`);
    });
  });

  describe('Memory Usage Tests', () => {
    it('should cleanup event listeners and subscriptions', async () => {
      const { unmount } = render(
        <ActivitySuggestions 
          outcomeIds={['FR4.1']}
          
        />, 
        { wrapper }
      );

      // Simulate component cleanup
      unmount();

      // Test that query client is properly cleaned up
      expect(queryClient.getQueryCache().getAll()).toHaveLength(0);
    });

    it('should handle component unmounting during async operations', async () => {
      // Mock a slow API response
      (global.fetch as Mock<typeof fetch>).mockImplementation(
        () => new Promise(resolve => setTimeout(() => resolve({
          ok: true,
          json: async () => [],
        } as Response), 5000))
      );

      const { unmount } = render(
        <ActivitySuggestions 
          outcomeIds={['FR4.1']}
          
        />, 
        { wrapper }
      );

      // Unmount immediately
      unmount();

      // Should not throw errors or cause memory leaks
      expect(true).toBe(true);
    });
  });
});